
Build/main.elf:     file format elf32-littlearm

SYMBOL TABLE:
08000000 l    d  .isr_vector	00000000 .isr_vector
080001c8 l    d  .text	00000000 .text
080010a8 l    d  .rodata	00000000 .rodata
080010c0 l    d  .init_array	00000000 .init_array
080010c8 l    d  .fini_array	00000000 .fini_array
20000000 l    d  .data	00000000 .data
20000430 l    d  .bss	00000000 .bss
20000450 l    d  ._user_heap_stack	00000000 ._user_heap_stack
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 /tmp/ccFcAG90.o
08000420 l       .text	00000000 LoopCopyDataInit
08000418 l       .text	00000000 CopyDataInit
08000434 l       .text	00000000 LoopFillZerobss
0800042e l       .text	00000000 FillZerobss
08000460 l       .text	00000000 Infinite_Loop
00000000 l    df *ABS*	00000000 crtstuff.c
08001090 l     O .text	00000000 __EH_FRAME_BEGIN__
080001c8 l     F .text	00000000 deregister_tm_clones
080001e8 l     F .text	00000000 register_tm_clones
0800020c l     F .text	00000000 __do_global_dtors_aux
20000430 l       .bss	00000000 completed.6516
080010c8 l     O .fini_array	00000000 __do_global_dtors_aux_fini_array_entry
08000234 l     F .text	00000000 frame_dummy
20000434 l       .bss	00000000 object.6521
080010c4 l     O .init_array	00000000 __frame_dummy_init_array_entry
00000000 l    df *ABS*	00000000 main.c
0800026c l     F .text	00000022 Error_Handler
00000000 l    df *ABS*	00000000 stm32f7xx_hal_msp.c
00000000 l    df *ABS*	00000000 stm32f7xx_it.c
00000000 l    df *ABS*	00000000 system_stm32f7xx.c
00000000 l    df *ABS*	00000000 stm32f7xx_hal_rcc.c
00000000 l    df *ABS*	00000000 stm32f7xx_hal.c
2000044c l     O .bss	00000004 uwTick
00000000 l    df *ABS*	00000000 stm32f7xx_hal_gpio.c
00000000 l    df *ABS*	00000000 stm32f7xx_hal_cortex.c
00000000 l    df *ABS*	00000000 stm32f7xx_hal_pwr_ex.c
00000000 l    df *ABS*	00000000 stm32746g_discovery.c
00000000 l    df *ABS*	00000000 init.c
00000000 l    df *ABS*	00000000 __call_atexit.c
08000fa4 l     F .text	00000014 register_fini
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 fini.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 /usr/bin/../lib/gcc/arm-none-eabi/5.2.1/armv7e-m/fpu/crti.o
00000000 l    df *ABS*	00000000 /usr/bin/../lib/gcc/arm-none-eabi/5.2.1/armv7e-m/fpu/crtn.o
00000000 l    df *ABS*	00000000 impure.c
20000008 l     O .data	00000428 impure_data
00000000 l    df *ABS*	00000000 
080010cc l       .fini_array	00000000 __fini_array_end
20000430 l       .bss	00000000 __bss_start__
20000450 l       .bss	00000000 __bss_end__
080010c8 l       .fini_array	00000000 __fini_array_start
080010c8 l       .init_array	00000000 __init_array_end
080010c0 l       .init_array	00000000 __preinit_array_end
080010c0 l       .init_array	00000000 __init_array_start
080010c0 l       .init_array	00000000 __preinit_array_start
08000460  w    F .text	00000002 RTC_Alarm_IRQHandler
080010a8 g     O .rodata	00000010 APBAHBPrescTable
08000460  w    F .text	00000002 EXTI2_IRQHandler
08000460  w    F .text	00000002 TIM8_CC_IRQHandler
08000470 g     F .text	00000002 DebugMon_Handler
08000460  w    F .text	00000002 UART8_IRQHandler
08000460  w    F .text	00000002 SPI4_IRQHandler
08000d74 g     F .text	00000070 HAL_NVIC_SetPriority
08000460  w    F .text	00000002 TIM1_CC_IRQHandler
08000460  w    F .text	00000002 DMA2_Stream5_IRQHandler
08000466 g     F .text	00000002 HardFault_Handler
08000460  w    F .text	00000002 DMA1_Stream5_IRQHandler
00000400 g       *ABS*	00000000 _Min_Stack_Size
08000474 g     F .text	00000004 SysTick_Handler
08000d40 g     F .text	00000008 HAL_GPIO_WritePin
08000460  w    F .text	00000002 PVD_IRQHandler
08000460  w    F .text	00000002 TAMP_STAMP_IRQHandler
080010cc g       *ABS*	00000000 _sidata
08000aac g     F .text	00000034 HAL_RCC_GetHCLKFreq
08000472 g     F .text	00000002 PendSV_Handler
08000464 g     F .text	00000002 NMI_Handler
080010c0 g       .init_array	00000000 __exidx_end
08000460  w    F .text	00000002 CAN2_RX1_IRQHandler
08000460  w    F .text	00000002 EXTI3_IRQHandler
08000a30 g     F .text	0000007c HAL_RCC_GetSysClockFreq
08000f30 g     F .text	00000014 BSP_LED_Off
08000460  w    F .text	00000002 TIM8_TRG_COM_TIM14_IRQHandler
08000462 g     F .text	00000002 HAL_MspInit
08000460  w    F .text	00000002 TIM1_UP_TIM10_IRQHandler
08000d48 g     F .text	00000008 HAL_GPIO_TogglePin
080010a8 g       .text	00000000 _etext
20000430 g       .bss	00000000 _sbss
08000460  w    F .text	00000002 TIM8_UP_TIM13_IRQHandler
08000e5c g     F .text	00000074 HAL_PWREx_EnableOverDrive
08000460  w    F .text	00000002 I2C3_ER_IRQHandler
08000b60 g     F .text	000001e0 HAL_GPIO_Init
20000430 g     O .data	00000000 .hidden __TMC_END__
08000460  w    F .text	00000002 EXTI0_IRQHandler
08000460  w    F .text	00000002 I2C2_EV_IRQHandler
08000460  w    F .text	00000002 DMA1_Stream2_IRQHandler
08000460  w    F .text	00000002 CAN1_RX0_IRQHandler
08000460  w    F .text	00000002 FPU_IRQHandler
08000b44  w    F .text	0000001a HAL_Delay
20000000 g     O .data	00000004 SystemCoreClock
08000460  w    F .text	00000002 OTG_HS_WKUP_IRQHandler
0800046c g     F .text	00000002 UsageFault_Handler
08000460  w    F .text	00000002 LTDC_ER_IRQHandler
08000460  w    F .text	00000002 CAN2_SCE_IRQHandler
08000460  w    F .text	00000002 DMA2_Stream2_IRQHandler
20000000 g       .data	00000000 _sdata
08000460  w    F .text	00000002 SPI1_IRQHandler
08000460  w    F .text	00000002 TIM6_DAC_IRQHandler
08000460  w    F .text	00000002 TIM1_BRK_TIM9_IRQHandler
08000460  w    F .text	00000002 DCMI_IRQHandler
08000460  w    F .text	00000002 CAN2_RX0_IRQHandler
08000de4 g     F .text	0000002c HAL_SYSTICK_Config
080010c0 g       .init_array	00000000 __exidx_start
08000460  w    F .text	00000002 DMA2_Stream3_IRQHandler
080010bc g     O .rodata	00000004 _global_impure_ptr
08000f54 g     F .text	00000050 __libc_init_array
08000460  w    F .text	00000002 SAI2_IRQHandler
08000460  w    F .text	00000002 USART6_IRQHandler
08001090 g     F .text	00000000 _init
08000460  w    F .text	00000002 USART3_IRQHandler
08000fc4 g     F .text	00000028 __libc_fini_array
20000450 g       .bss	00000000 _ebss
08000410  w    F .text	00000038 Reset_Handler
08000460  w    F .text	00000002 CAN1_RX1_IRQHandler
08000460  w    F .text	00000002 UART5_IRQHandler
08000460  w    F .text	00000002 DMA2_Stream0_IRQHandler
08000b04 g     F .text	00000024 HAL_Init
08000460  w    F .text	00000002 TIM4_IRQHandler
08000460  w    F .text	00000002 QUADSPI_IRQHandler
08000460  w    F .text	00000002 I2C1_EV_IRQHandler
08000460  w    F .text	00000002 DMA1_Stream6_IRQHandler
08000f1c g     F .text	00000014 BSP_LED_On
08000460  w    F .text	00000002 DMA1_Stream1_IRQHandler
08000460  w    F .text	00000002 UART4_IRQHandler
08000460  w    F .text	00000002 TIM3_IRQHandler
08000460  w    F .text	00000002 RCC_IRQHandler
08000460  w    F .text	00000002 TIM8_BRK_TIM12_IRQHandler
00000200 g       *ABS*	00000000 _Min_Heap_Size
08000460 g       .text	00000002 Default_Handler
08000460  w    F .text	00000002 CEC_IRQHandler
08000460  w    F .text	00000002 EXTI15_10_IRQHandler
08000fec g     F .text	000000a4 __register_exitproc
08000460  w    F .text	00000002 ADC_IRQHandler
08000874 g     F .text	000001bc HAL_RCC_ClockConfig
08000d50 g     F .text	00000024 HAL_NVIC_SetPriorityGrouping
08000460  w    F .text	00000002 DMA1_Stream7_IRQHandler
08000460  w    F .text	00000002 SPI5_IRQHandler
08000460  w    F .text	00000002 TIM7_IRQHandler
08000460  w    F .text	00000002 SDMMC1_IRQHandler
08000460  w    F .text	00000002 CAN2_TX_IRQHandler
08000460  w    F .text	00000002 TIM5_IRQHandler
08000460  w    F .text	00000002 DMA2_Stream7_IRQHandler
08000460  w    F .text	00000002 I2C3_EV_IRQHandler
08000460  w    F .text	00000002 EXTI9_5_IRQHandler
08000460  w    F .text	00000002 RTC_WKUP_IRQHandler
08000460  w    F .text	00000002 LTDC_IRQHandler
08000460  w    F .text	00000002 ETH_WKUP_IRQHandler
08000b38  w    F .text	0000000c HAL_GetTick
08000460  w    F .text	00000002 SPDIF_RX_IRQHandler
08000460  w    F .text	00000002 SPI2_IRQHandler
08000460  w    F .text	00000002 OTG_HS_EP1_IN_IRQHandler
08000468 g     F .text	00000002 MemManage_Handler
08000290 g     F .text	00000180 main
08000460  w    F .text	00000002 DMA1_Stream0_IRQHandler
08000460  w    F .text	00000002 CAN1_TX_IRQHandler
0800046e g     F .text	00000002 SVC_Handler
08000460  w    F .text	00000002 EXTI4_IRQHandler
08000478 g     F .text	0000004c SystemInit
08000460  w    F .text	00000002 RNG_IRQHandler
0800109c g     F .text	00000000 _fini
08000fb8 g     F .text	0000000c atexit
08000ae0  w    F .text	00000024 HAL_InitTick
08000460  w    F .text	00000002 ETH_IRQHandler
08000b28  w    F .text	00000010 HAL_IncTick
08000460  w    F .text	00000002 OTG_HS_EP1_OUT_IRQHandler
08000460  w    F .text	00000002 WWDG_IRQHandler
08000460  w    F .text	00000002 SPI6_IRQHandler
08000460  w    F .text	00000002 I2C4_EV_IRQHandler
08000460  w    F .text	00000002 TIM2_IRQHandler
08000460  w    F .text	00000002 OTG_FS_WKUP_IRQHandler
08000460  w    F .text	00000002 TIM1_TRG_COM_TIM11_IRQHandler
08000460  w    F .text	00000002 OTG_HS_IRQHandler
08000f44 g     F .text	00000010 BSP_LED_Toggle
08000460  w    F .text	00000002 DMA2D_IRQHandler
2004ffff g       *ABS*	00000000 _estack
08000460  w    F .text	00000002 EXTI1_IRQHandler
20000430 g       .data	00000000 _edata
08000460  w    F .text	00000002 UART7_IRQHandler
08000460  w    F .text	00000002 USART2_IRQHandler
080004c4 g     F .text	000003b0 HAL_RCC_OscConfig
08000000 g     O .isr_vector	00000000 g_pfnVectors
08000460  w    F .text	00000002 I2C2_ER_IRQHandler
08000ed0 g     F .text	0000004c BSP_LED_Init
08000e10 g     F .text	0000004c HAL_MPU_ConfigRegion
08000460  w    F .text	00000002 DMA2_Stream1_IRQHandler
08000460  w    F .text	00000002 CAN1_SCE_IRQHandler
08000460  w    F .text	00000002 FLASH_IRQHandler
08000460  w    F .text	00000002 DMA2_Stream4_IRQHandler
0800046a g     F .text	00000002 BusFault_Handler
08000460  w    F .text	00000002 USART1_IRQHandler
08000460  w    F .text	00000002 OTG_FS_IRQHandler
08000460  w    F .text	00000002 SPI3_IRQHandler
08000460  w    F .text	00000002 DMA1_Stream4_IRQHandler
08000460  w    F .text	00000002 I2C1_ER_IRQHandler
08000460  w    F .text	00000002 FMC_IRQHandler
08000460  w    F .text	00000002 LPTIM1_IRQHandler
08000460  w    F .text	00000002 I2C4_ER_IRQHandler
08000460  w    F .text	00000002 DMA2_Stream6_IRQHandler
08000460  w    F .text	00000002 SAI1_IRQHandler
08000460  w    F .text	00000002 DMA1_Stream3_IRQHandler



Disassembly of section .text:

080001c8 <deregister_tm_clones>:
 80001c8:	4b04      	ldr	r3, [pc, #16]	; (80001dc <deregister_tm_clones+0x14>)
 80001ca:	4805      	ldr	r0, [pc, #20]	; (80001e0 <deregister_tm_clones+0x18>)
 80001cc:	1a1b      	subs	r3, r3, r0
 80001ce:	2b06      	cmp	r3, #6
 80001d0:	d902      	bls.n	80001d8 <deregister_tm_clones+0x10>
 80001d2:	4b04      	ldr	r3, [pc, #16]	; (80001e4 <deregister_tm_clones+0x1c>)
 80001d4:	b103      	cbz	r3, 80001d8 <deregister_tm_clones+0x10>
 80001d6:	4718      	bx	r3
 80001d8:	4770      	bx	lr
 80001da:	bf00      	nop
 80001dc:	20000433 	.word	0x20000433
 80001e0:	20000430 	.word	0x20000430
 80001e4:	00000000 	.word	0x00000000

080001e8 <register_tm_clones>:
 80001e8:	4905      	ldr	r1, [pc, #20]	; (8000200 <register_tm_clones+0x18>)
 80001ea:	4806      	ldr	r0, [pc, #24]	; (8000204 <register_tm_clones+0x1c>)
 80001ec:	1a09      	subs	r1, r1, r0
 80001ee:	1089      	asrs	r1, r1, #2
 80001f0:	eb01 71d1 	add.w	r1, r1, r1, lsr #31
 80001f4:	1049      	asrs	r1, r1, #1
 80001f6:	d002      	beq.n	80001fe <register_tm_clones+0x16>
 80001f8:	4b03      	ldr	r3, [pc, #12]	; (8000208 <register_tm_clones+0x20>)
 80001fa:	b103      	cbz	r3, 80001fe <register_tm_clones+0x16>
 80001fc:	4718      	bx	r3
 80001fe:	4770      	bx	lr
 8000200:	20000430 	.word	0x20000430
 8000204:	20000430 	.word	0x20000430
 8000208:	00000000 	.word	0x00000000

0800020c <__do_global_dtors_aux>:
 800020c:	b510      	push	{r4, lr}
 800020e:	4c06      	ldr	r4, [pc, #24]	; (8000228 <__do_global_dtors_aux+0x1c>)
 8000210:	7823      	ldrb	r3, [r4, #0]
 8000212:	b943      	cbnz	r3, 8000226 <__do_global_dtors_aux+0x1a>
 8000214:	f7ff ffd8 	bl	80001c8 <deregister_tm_clones>
 8000218:	4b04      	ldr	r3, [pc, #16]	; (800022c <__do_global_dtors_aux+0x20>)
 800021a:	b113      	cbz	r3, 8000222 <__do_global_dtors_aux+0x16>
 800021c:	4804      	ldr	r0, [pc, #16]	; (8000230 <__do_global_dtors_aux+0x24>)
 800021e:	f3af 8000 	nop.w
 8000222:	2301      	movs	r3, #1
 8000224:	7023      	strb	r3, [r4, #0]
 8000226:	bd10      	pop	{r4, pc}
 8000228:	20000430 	.word	0x20000430
 800022c:	00000000 	.word	0x00000000
 8000230:	08001090 	.word	0x08001090

08000234 <frame_dummy>:
 8000234:	b508      	push	{r3, lr}
 8000236:	4b08      	ldr	r3, [pc, #32]	; (8000258 <frame_dummy+0x24>)
 8000238:	b11b      	cbz	r3, 8000242 <frame_dummy+0xe>
 800023a:	4908      	ldr	r1, [pc, #32]	; (800025c <frame_dummy+0x28>)
 800023c:	4808      	ldr	r0, [pc, #32]	; (8000260 <frame_dummy+0x2c>)
 800023e:	f3af 8000 	nop.w
 8000242:	4808      	ldr	r0, [pc, #32]	; (8000264 <frame_dummy+0x30>)
 8000244:	6803      	ldr	r3, [r0, #0]
 8000246:	b913      	cbnz	r3, 800024e <frame_dummy+0x1a>
 8000248:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 800024c:	e7cc      	b.n	80001e8 <register_tm_clones>
 800024e:	4b06      	ldr	r3, [pc, #24]	; (8000268 <frame_dummy+0x34>)
 8000250:	2b00      	cmp	r3, #0
 8000252:	d0f9      	beq.n	8000248 <frame_dummy+0x14>
 8000254:	4798      	blx	r3
 8000256:	e7f7      	b.n	8000248 <frame_dummy+0x14>
 8000258:	00000000 	.word	0x00000000
 800025c:	20000434 	.word	0x20000434
 8000260:	08001090 	.word	0x08001090
 8000264:	20000430 	.word	0x20000430
 8000268:	00000000 	.word	0x00000000

0800026c <Error_Handler>:
  * @brief  This function is executed in case of error occurrence.
  * @param  None
  * @retval None
  */
static void Error_Handler(void)
{
 800026c:	b510      	push	{r4, lr}
 800026e:	2403      	movs	r4, #3
  uint8_t i=0;
  /* User may add here some code to deal with this error */
  while(1)
  {
      for (i=0; i<3; i++) {
          BSP_LED_Toggle(LED1);
 8000270:	2000      	movs	r0, #0
 8000272:	3c01      	subs	r4, #1
 8000274:	f000 fe66 	bl	8000f44 <BSP_LED_Toggle>
          HAL_Delay(100);
 8000278:	2064      	movs	r0, #100	; 0x64
 800027a:	f000 fc63 	bl	8000b44 <HAL_Delay>
{
  uint8_t i=0;
  /* User may add here some code to deal with this error */
  while(1)
  {
      for (i=0; i<3; i++) {
 800027e:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
 8000282:	d1f5      	bne.n	8000270 <Error_Handler+0x4>
          BSP_LED_Toggle(LED1);
          HAL_Delay(100);
      }
      HAL_Delay(500);
 8000284:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8000288:	f000 fc5c 	bl	8000b44 <HAL_Delay>
  }
 800028c:	e7ef      	b.n	800026e <Error_Handler+0x2>
	...

08000290 <main>:
  * @retval None
  */
__STATIC_INLINE void HAL_MPU_Disable(void)
{
  /* Disable fault exceptions */
  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
 8000290:	4c5a      	ldr	r4, [pc, #360]	; (80003fc <main+0x16c>)
  /* Configure the MPU attributes as WT for SRAM */
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
  MPU_InitStruct.BaseAddress = 0x20010000;
  MPU_InitStruct.Size = MPU_REGION_SIZE_256KB;
  MPU_InitStruct.AccessPermission = MPU_REGION_FULL_ACCESS;
  MPU_InitStruct.IsBufferable = MPU_ACCESS_NOT_BUFFERABLE;
 8000292:	2500      	movs	r5, #0
  
  /* Disable the MPU */
  MPU->CTRL  &= ~MPU_CTRL_ENABLE_Msk;
 8000294:	4e5a      	ldr	r6, [pc, #360]	; (8000400 <main+0x170>)
  * @retval None
  */
__STATIC_INLINE void HAL_MPU_Disable(void)
{
  /* Disable fault exceptions */
  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
 8000296:	6a63      	ldr	r3, [r4, #36]	; 0x24
  /* Disable the MPU */
  HAL_MPU_Disable();

  /* Configure the MPU attributes as WT for SRAM */
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
  MPU_InitStruct.BaseAddress = 0x20010000;
 8000298:	4a5a      	ldr	r2, [pc, #360]	; (8000404 <main+0x174>)
 800029a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
  * @brief  Main program
  * @param  None
  * @retval None
  */
int main(void)
{
 800029e:	b500      	push	{lr}
 80002a0:	6263      	str	r3, [r4, #36]	; 0x24
 80002a2:	b095      	sub	sp, #84	; 0x54
  
  /* Disable the MPU */
  MPU->CTRL  &= ~MPU_CTRL_ENABLE_Msk;
 80002a4:	6873      	ldr	r3, [r6, #4]
  MPU_InitStruct.Number = MPU_REGION_NUMBER0;
  MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
  MPU_InitStruct.SubRegionDisable = 0x00;
  MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_ENABLE;

  HAL_MPU_ConfigRegion(&MPU_InitStruct);
 80002a6:	a808      	add	r0, sp, #32
 80002a8:	f023 0301 	bic.w	r3, r3, #1
 80002ac:	6073      	str	r3, [r6, #4]
  
  /* Disable the MPU */
  HAL_MPU_Disable();

  /* Configure the MPU attributes as WT for SRAM */
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
 80002ae:	2301      	movs	r3, #1
  MPU_InitStruct.BaseAddress = 0x20010000;
 80002b0:	9209      	str	r2, [sp, #36]	; 0x24
  MPU_InitStruct.Size = MPU_REGION_SIZE_256KB;
 80002b2:	2211      	movs	r2, #17
  
  /* Disable the MPU */
  HAL_MPU_Disable();

  /* Configure the MPU attributes as WT for SRAM */
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
 80002b4:	f88d 3020 	strb.w	r3, [sp, #32]
  MPU_InitStruct.BaseAddress = 0x20010000;
  MPU_InitStruct.Size = MPU_REGION_SIZE_256KB;
 80002b8:	f88d 2028 	strb.w	r2, [sp, #40]	; 0x28
  MPU_InitStruct.AccessPermission = MPU_REGION_FULL_ACCESS;
 80002bc:	2203      	movs	r2, #3
  MPU_InitStruct.IsBufferable = MPU_ACCESS_NOT_BUFFERABLE;
  MPU_InitStruct.IsCacheable = MPU_ACCESS_CACHEABLE;
 80002be:	f88d 302e 	strb.w	r3, [sp, #46]	; 0x2e

  /* Configure the MPU attributes as WT for SRAM */
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
  MPU_InitStruct.BaseAddress = 0x20010000;
  MPU_InitStruct.Size = MPU_REGION_SIZE_256KB;
  MPU_InitStruct.AccessPermission = MPU_REGION_FULL_ACCESS;
 80002c2:	f88d 202b 	strb.w	r2, [sp, #43]	; 0x2b
  MPU_InitStruct.IsBufferable = MPU_ACCESS_NOT_BUFFERABLE;
 80002c6:	f88d 502f 	strb.w	r5, [sp, #47]	; 0x2f
  MPU_InitStruct.IsCacheable = MPU_ACCESS_CACHEABLE;
  MPU_InitStruct.IsShareable = MPU_ACCESS_NOT_SHAREABLE;
 80002ca:	f88d 502d 	strb.w	r5, [sp, #45]	; 0x2d
  MPU_InitStruct.Number = MPU_REGION_NUMBER0;
 80002ce:	f88d 5021 	strb.w	r5, [sp, #33]	; 0x21
  MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
 80002d2:	f88d 502a 	strb.w	r5, [sp, #42]	; 0x2a
  MPU_InitStruct.SubRegionDisable = 0x00;
 80002d6:	f88d 5029 	strb.w	r5, [sp, #41]	; 0x29
  MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_ENABLE;
 80002da:	f88d 502c 	strb.w	r5, [sp, #44]	; 0x2c

  HAL_MPU_ConfigRegion(&MPU_InitStruct);
 80002de:	f000 fd97 	bl	8000e10 <HAL_MPU_ConfigRegion>
  * @retval None
  */
__STATIC_INLINE void HAL_MPU_Enable(uint32_t MPU_Control)
{
  /* Enable the MPU */
  MPU->CTRL   = MPU_Control | MPU_CTRL_ENABLE_Msk;
 80002e2:	2305      	movs	r3, #5
 80002e4:	6073      	str	r3, [r6, #4]
  
  /* Enable fault exceptions */
  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;
 80002e6:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80002e8:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80002ec:	6263      	str	r3, [r4, #36]	; 0x24
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 80002ee:	f3bf 8f4f 	dsb	sy
           so that all instructions following the ISB are fetched from cache or memory,
           after the instruction has been completed.
 */
__attribute__((always_inline)) __STATIC_INLINE void __ISB(void)
{
  __ASM volatile ("isb 0xF":::"memory");
 80002f2:	f3bf 8f6f 	isb	sy
__STATIC_INLINE void SCB_EnableICache (void)
{
  #if (__ICACHE_PRESENT == 1U)
    __DSB();
    __ISB();
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
 80002f6:	f8c4 5250 	str.w	r5, [r4, #592]	; 0x250
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
 80002fa:	6963      	ldr	r3, [r4, #20]
 80002fc:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8000300:	6163      	str	r3, [r4, #20]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8000302:	f3bf 8f4f 	dsb	sy
           so that all instructions following the ISB are fetched from cache or memory,
           after the instruction has been completed.
 */
__attribute__((always_inline)) __STATIC_INLINE void __ISB(void)
{
  __ASM volatile ("isb 0xF":::"memory");
 8000306:	f3bf 8f6f 	isb	sy
  #if (__DCACHE_PRESENT == 1U)
    uint32_t ccsidr;
    uint32_t sets;
    uint32_t ways;

    SCB->CSSELR = (0U << 1U) | 0U;          /* Level 1 data cache */
 800030a:	f8c4 5084 	str.w	r5, [r4, #132]	; 0x84
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 800030e:	f3bf 8f4f 	dsb	sy
    __DSB();

    ccsidr = SCB->CCSIDR;
 8000312:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80

                                            /* invalidate D-Cache */
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
 8000316:	f3c2 334e 	ubfx	r3, r2, #13, #15
    do {
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 800031a:	f3c2 02c9 	ubfx	r2, r2, #3, #10
      do {
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 800031e:	0159      	lsls	r1, r3, #5
 8000320:	f643 70e0 	movw	r0, #16352	; 0x3fe0
 8000324:	4008      	ands	r0, r1
    ccsidr = SCB->CCSIDR;

                                            /* invalidate D-Cache */
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
    do {
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 8000326:	4611      	mov	r1, r2
      do {
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 8000328:	ea40 7681 	orr.w	r6, r0, r1, lsl #30
                      ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );
        #if defined ( __CC_ARM )
          __schedule_barrier();
        #endif
      } while (ways--);
 800032c:	f111 31ff 	adds.w	r1, r1, #4294967295	; 0xffffffff
                                            /* invalidate D-Cache */
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
    do {
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
      do {
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 8000330:	4d32      	ldr	r5, [pc, #200]	; (80003fc <main+0x16c>)
 8000332:	f8c4 6260 	str.w	r6, [r4, #608]	; 0x260
                      ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );
        #if defined ( __CC_ARM )
          __schedule_barrier();
        #endif
      } while (ways--);
 8000336:	d2f7      	bcs.n	8000328 <main+0x98>
    } while(sets--);
 8000338:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 800033c:	d2ef      	bcs.n	800031e <main+0x8e>
 800033e:	f3bf 8f4f 	dsb	sy
    __DSB();

    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
 8000342:	696b      	ldr	r3, [r5, #20]
 8000344:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8000348:	616b      	str	r3, [r5, #20]
 800034a:	f3bf 8f4f 	dsb	sy
           so that all instructions following the ISB are fetched from cache or memory,
           after the instruction has been completed.
 */
__attribute__((always_inline)) __STATIC_INLINE void __ISB(void)
{
  __ASM volatile ("isb 0xF":::"memory");
 800034e:	f3bf 8f6f 	isb	sy
       - Configure the Flash ART accelerator on ITCM interface
       - Configure the Systick to generate an interrupt each 1 msec
       - Set NVIC Group Priority to 4
       - Low Level Initialization
     */
  HAL_Init();
 8000352:	f000 fbd7 	bl	8000b04 <HAL_Init>
  HAL_StatusTypeDef ret = HAL_OK;
  RCC_ClkInitTypeDef RCC_ClkInitStruct;
  RCC_OscInitTypeDef RCC_OscInitStruct;
  
  /* Enable Power Control clock */
  __HAL_RCC_PWR_CLK_ENABLE();
 8000356:	4b2c      	ldr	r3, [pc, #176]	; (8000408 <main+0x178>)
 8000358:	2100      	movs	r1, #0
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  /* Enable HSE Oscillator and activate PLL with HSE as source */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 800035a:	2402      	movs	r4, #2
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 25;
  RCC_OscInitStruct.PLL.PLLN = 400;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 8;
  ret = HAL_RCC_OscConfig(&RCC_OscInitStruct);
 800035c:	a808      	add	r0, sp, #32
  HAL_StatusTypeDef ret = HAL_OK;
  RCC_ClkInitTypeDef RCC_ClkInitStruct;
  RCC_OscInitTypeDef RCC_OscInitStruct;
  
  /* Enable Power Control clock */
  __HAL_RCC_PWR_CLK_ENABLE();
 800035e:	9101      	str	r1, [sp, #4]
 8000360:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8000362:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8000366:	641a      	str	r2, [r3, #64]	; 0x40
 8000368:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800036a:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800036e:	9301      	str	r3, [sp, #4]
 8000370:	9b01      	ldr	r3, [sp, #4]

  /* The voltage scaling allows optimizing the power consumption when the device is
     clocked below the maximum system frequency, to update the voltage scaling value 
     regarding system frequency refer to product datasheet.  */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8000372:	4b26      	ldr	r3, [pc, #152]	; (800040c <main+0x17c>)
 8000374:	9102      	str	r1, [sp, #8]
 8000376:	681a      	ldr	r2, [r3, #0]
 8000378:	f442 4240 	orr.w	r2, r2, #49152	; 0xc000
 800037c:	601a      	str	r2, [r3, #0]
 800037e:	681b      	ldr	r3, [r3, #0]

  /* Enable HSE Oscillator and activate PLL with HSE as source */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8000380:	940e      	str	r4, [sp, #56]	; 0x38
  __HAL_RCC_PWR_CLK_ENABLE();

  /* The voltage scaling allows optimizing the power consumption when the device is
     clocked below the maximum system frequency, to update the voltage scaling value 
     regarding system frequency refer to product datasheet.  */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8000382:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 25;
  RCC_OscInitStruct.PLL.PLLN = 400;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 8000386:	9412      	str	r4, [sp, #72]	; 0x48
  __HAL_RCC_PWR_CLK_ENABLE();

  /* The voltage scaling allows optimizing the power consumption when the device is
     clocked below the maximum system frequency, to update the voltage scaling value 
     regarding system frequency refer to product datasheet.  */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8000388:	9302      	str	r3, [sp, #8]
 800038a:	9b02      	ldr	r3, [sp, #8]

  /* Enable HSE Oscillator and activate PLL with HSE as source */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 800038c:	2301      	movs	r3, #1
 800038e:	9308      	str	r3, [sp, #32]
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 8000390:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8000394:	9309      	str	r3, [sp, #36]	; 0x24
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8000396:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 800039a:	930f      	str	r3, [sp, #60]	; 0x3c
  RCC_OscInitStruct.PLL.PLLM = 25;
 800039c:	2319      	movs	r3, #25
 800039e:	9310      	str	r3, [sp, #64]	; 0x40
  RCC_OscInitStruct.PLL.PLLN = 400;
 80003a0:	f44f 73c8 	mov.w	r3, #400	; 0x190
 80003a4:	9311      	str	r3, [sp, #68]	; 0x44
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 8;
 80003a6:	2308      	movs	r3, #8
 80003a8:	9313      	str	r3, [sp, #76]	; 0x4c
  ret = HAL_RCC_OscConfig(&RCC_OscInitStruct);
 80003aa:	f000 f88b 	bl	80004c4 <HAL_RCC_OscConfig>
  if(ret != HAL_OK) Error_Handler();
 80003ae:	b108      	cbz	r0, 80003b4 <main+0x124>
 80003b0:	f7ff ff5c 	bl	800026c <Error_Handler>

  /* activate the OverDrive to reach the 180 Mhz Frequency */
  ret = HAL_PWREx_ActivateOverDrive();
 80003b4:	f000 fd52 	bl	8000e5c <HAL_PWREx_EnableOverDrive>
  if(ret != HAL_OK) Error_Handler();
 80003b8:	2800      	cmp	r0, #0
 80003ba:	d1f9      	bne.n	80003b0 <main+0x120>

  /* Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2
     clocks dividers */
  RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
 80003bc:	230f      	movs	r3, #15
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 80003be:	9005      	str	r0, [sp, #20]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;

  if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK) Error_Handler();
 80003c0:	2105      	movs	r1, #5
 80003c2:	a803      	add	r0, sp, #12
  ret = HAL_PWREx_ActivateOverDrive();
  if(ret != HAL_OK) Error_Handler();

  /* Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2
     clocks dividers */
  RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
 80003c4:	9303      	str	r3, [sp, #12]
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
 80003c6:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
  if(ret != HAL_OK) Error_Handler();

  /* Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2
     clocks dividers */
  RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 80003ca:	9404      	str	r4, [sp, #16]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
 80003cc:	9306      	str	r3, [sp, #24]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 80003ce:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80003d2:	9307      	str	r3, [sp, #28]

  if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK) Error_Handler();
 80003d4:	f000 fa4e 	bl	8000874 <HAL_RCC_ClockConfig>
 80003d8:	2800      	cmp	r0, #0
 80003da:	d1e9      	bne.n	80003b0 <main+0x120>
  HAL_Init();

  /* Configure the System clock to have a frequency of 216 MHz */
  SystemClock_Config();

  BSP_LED_Init(LED1);
 80003dc:	f000 fd78 	bl	8000ed0 <BSP_LED_Init>


  /* Infinite loop */
  while (1)
  {
      BSP_LED_On(LED1);
 80003e0:	2000      	movs	r0, #0
 80003e2:	f000 fd9b 	bl	8000f1c <BSP_LED_On>
      HAL_Delay(100);
 80003e6:	2064      	movs	r0, #100	; 0x64
 80003e8:	f000 fbac 	bl	8000b44 <HAL_Delay>
      BSP_LED_Off(LED1);
 80003ec:	2000      	movs	r0, #0
 80003ee:	f000 fd9f 	bl	8000f30 <BSP_LED_Off>
      HAL_Delay(400);
 80003f2:	f44f 70c8 	mov.w	r0, #400	; 0x190
 80003f6:	f000 fba5 	bl	8000b44 <HAL_Delay>
 80003fa:	e7f1      	b.n	80003e0 <main+0x150>
 80003fc:	e000ed00 	.word	0xe000ed00
 8000400:	e000ed90 	.word	0xe000ed90
 8000404:	20010000 	.word	0x20010000
 8000408:	40023800 	.word	0x40023800
 800040c:	40007000 	.word	0x40007000

08000410 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack      /* set stack pointer */
 8000410:	f8df d034 	ldr.w	sp, [pc, #52]	; 8000448 <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 8000414:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 8000416:	e003      	b.n	8000420 <LoopCopyDataInit>

08000418 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 8000418:	4b0c      	ldr	r3, [pc, #48]	; (800044c <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
 800041a:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 800041c:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 800041e:	3104      	adds	r1, #4

08000420 <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 8000420:	480b      	ldr	r0, [pc, #44]	; (8000450 <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
 8000422:	4b0c      	ldr	r3, [pc, #48]	; (8000454 <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
 8000424:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 8000426:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 8000428:	d3f6      	bcc.n	8000418 <CopyDataInit>
  ldr  r2, =_sbss
 800042a:	4a0b      	ldr	r2, [pc, #44]	; (8000458 <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
 800042c:	e002      	b.n	8000434 <LoopFillZerobss>

0800042e <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 800042e:	2300      	movs	r3, #0
  str  r3, [r2], #4
 8000430:	f842 3b04 	str.w	r3, [r2], #4

08000434 <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 8000434:	4b09      	ldr	r3, [pc, #36]	; (800045c <LoopFillZerobss+0x28>)
  cmp  r2, r3
 8000436:	429a      	cmp	r2, r3
  bcc  FillZerobss
 8000438:	d3f9      	bcc.n	800042e <FillZerobss>

/* Call the clock system initialization function.*/
  bl  SystemInit   
 800043a:	f000 f81d 	bl	8000478 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 800043e:	f000 fd89 	bl	8000f54 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 8000442:	f7ff ff25 	bl	8000290 <main>
  bx  lr    
 8000446:	4770      	bx	lr

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack      /* set stack pointer */
 8000448:	2004ffff 	.word	0x2004ffff
/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
  b  LoopCopyDataInit

CopyDataInit:
  ldr  r3, =_sidata
 800044c:	080010cc 	.word	0x080010cc
  ldr  r3, [r3, r1]
  str  r3, [r0, r1]
  adds  r1, r1, #4
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 8000450:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 8000454:	20000430 	.word	0x20000430
  adds  r2, r0, r1
  cmp  r2, r3
  bcc  CopyDataInit
  ldr  r2, =_sbss
 8000458:	20000430 	.word	0x20000430
FillZerobss:
  movs  r3, #0
  str  r3, [r2], #4
    
LoopFillZerobss:
  ldr  r3, = _ebss
 800045c:	20000450 	.word	0x20000450

08000460 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8000460:	e7fe      	b.n	8000460 <ADC_IRQHandler>

08000462 <HAL_MspInit>:
 8000462:	4770      	bx	lr

08000464 <NMI_Handler>:
 8000464:	4770      	bx	lr

08000466 <HardFault_Handler>:
  * @brief  This function handles Hard Fault exception.
  * @param  None
  * @retval None
  */
void HardFault_Handler(void)
{
 8000466:	e7fe      	b.n	8000466 <HardFault_Handler>

08000468 <MemManage_Handler>:
  * @brief  This function handles Memory Manage exception.
  * @param  None
  * @retval None
  */
void MemManage_Handler(void)
{
 8000468:	e7fe      	b.n	8000468 <MemManage_Handler>

0800046a <BusFault_Handler>:
  * @brief  This function handles Bus Fault exception.
  * @param  None
  * @retval None
  */
void BusFault_Handler(void)
{
 800046a:	e7fe      	b.n	800046a <BusFault_Handler>

0800046c <UsageFault_Handler>:
  * @brief  This function handles Usage Fault exception.
  * @param  None
  * @retval None
  */
void UsageFault_Handler(void)
{
 800046c:	e7fe      	b.n	800046c <UsageFault_Handler>

0800046e <SVC_Handler>:
 800046e:	4770      	bx	lr

08000470 <DebugMon_Handler>:
 8000470:	4770      	bx	lr

08000472 <PendSV_Handler>:
  * @brief  This function handles PendSVC exception.
  * @param  None
  * @retval None
  */
void PendSV_Handler(void)
{
 8000472:	4770      	bx	lr

08000474 <SysTick_Handler>:
  * @param  None
  * @retval None
  */
void SysTick_Handler(void)
{
  HAL_IncTick();
 8000474:	f000 bb58 	b.w	8000b28 <HAL_IncTick>

08000478 <SystemInit>:
  */
void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8000478:	490f      	ldr	r1, [pc, #60]	; (80004b8 <SystemInit+0x40>)
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 800047a:	2000      	movs	r0, #0
  */
void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 800047c:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 8000480:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 8000484:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8000488:	4b0c      	ldr	r3, [pc, #48]	; (80004bc <SystemInit+0x44>)
 800048a:	681a      	ldr	r2, [r3, #0]
 800048c:	f042 0201 	orr.w	r2, r2, #1
 8000490:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8000492:	6098      	str	r0, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8000494:	681a      	ldr	r2, [r3, #0]
 8000496:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 800049a:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 800049e:	601a      	str	r2, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 80004a0:	4a07      	ldr	r2, [pc, #28]	; (80004c0 <SystemInit+0x48>)
 80004a2:	605a      	str	r2, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 80004a4:	681a      	ldr	r2, [r3, #0]
 80004a6:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80004aa:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 80004ac:	60d8      	str	r0, [r3, #12]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM1_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 80004ae:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 80004b2:	608b      	str	r3, [r1, #8]
 80004b4:	4770      	bx	lr
 80004b6:	bf00      	nop
 80004b8:	e000ed00 	.word	0xe000ed00
 80004bc:	40023800 	.word	0x40023800
 80004c0:	24003010 	.word	0x24003010

080004c4 <HAL_RCC_OscConfig>:
 
  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 80004c4:	6803      	ldr	r3, [r0, #0]
  *         contains the configuration information for the RCC Oscillators.
  * @note   The PLL is not disabled when used as system clock.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 80004c6:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 
  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 80004ca:	07dd      	lsls	r5, r3, #31
  *         contains the configuration information for the RCC Oscillators.
  * @note   The PLL is not disabled when used as system clock.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 80004cc:	4604      	mov	r4, r0
 
  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 80004ce:	d403      	bmi.n	80004d8 <HAL_RCC_OscConfig+0x14>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 80004d0:	6823      	ldr	r3, [r4, #0]
 80004d2:	0798      	lsls	r0, r3, #30
 80004d4:	d470      	bmi.n	80005b8 <HAL_RCC_OscConfig+0xf4>
 80004d6:	e0c3      	b.n	8000660 <HAL_RCC_OscConfig+0x19c>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL, It can not be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE) 
 80004d8:	4ba4      	ldr	r3, [pc, #656]	; (800076c <HAL_RCC_OscConfig+0x2a8>)
 80004da:	689a      	ldr	r2, [r3, #8]
 80004dc:	f002 020c 	and.w	r2, r2, #12
 80004e0:	2a04      	cmp	r2, #4
 80004e2:	d007      	beq.n	80004f4 <HAL_RCC_OscConfig+0x30>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 80004e4:	689a      	ldr	r2, [r3, #8]
 80004e6:	f002 020c 	and.w	r2, r2, #12
 80004ea:	2a08      	cmp	r2, #8
 80004ec:	d10b      	bne.n	8000506 <HAL_RCC_OscConfig+0x42>
 80004ee:	685b      	ldr	r3, [r3, #4]
 80004f0:	0259      	lsls	r1, r3, #9
 80004f2:	d508      	bpl.n	8000506 <HAL_RCC_OscConfig+0x42>
    {
	  if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 80004f4:	4b9d      	ldr	r3, [pc, #628]	; (800076c <HAL_RCC_OscConfig+0x2a8>)
 80004f6:	681b      	ldr	r3, [r3, #0]
 80004f8:	039a      	lsls	r2, r3, #14
 80004fa:	d5e9      	bpl.n	80004d0 <HAL_RCC_OscConfig+0xc>
 80004fc:	6863      	ldr	r3, [r4, #4]
 80004fe:	2b00      	cmp	r3, #0
 8000500:	d1e6      	bne.n	80004d0 <HAL_RCC_OscConfig+0xc>
      {
        return HAL_ERROR;
 8000502:	2001      	movs	r0, #1
 8000504:	e1b1      	b.n	800086a <HAL_RCC_OscConfig+0x3a6>
      }
    }
    else
    {
      /* Reset HSEON and HSEBYP bits before configuring the HSE --------------*/
      __HAL_RCC_HSE_CONFIG(RCC_HSE_OFF);
 8000506:	4d99      	ldr	r5, [pc, #612]	; (800076c <HAL_RCC_OscConfig+0x2a8>)
 8000508:	682b      	ldr	r3, [r5, #0]
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      /* Wait till HSE is disabled */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800050a:	462e      	mov	r6, r5
      }
    }
    else
    {
      /* Reset HSEON and HSEBYP bits before configuring the HSE --------------*/
      __HAL_RCC_HSE_CONFIG(RCC_HSE_OFF);
 800050c:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8000510:	602b      	str	r3, [r5, #0]
 8000512:	682b      	ldr	r3, [r5, #0]
 8000514:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8000518:	602b      	str	r3, [r5, #0]
 800051a:	682b      	ldr	r3, [r5, #0]
 800051c:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8000520:	602b      	str	r3, [r5, #0]
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8000522:	f000 fb09 	bl	8000b38 <HAL_GetTick>
 8000526:	4607      	mov	r7, r0
      
      /* Wait till HSE is disabled */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8000528:	6833      	ldr	r3, [r6, #0]
 800052a:	4d90      	ldr	r5, [pc, #576]	; (800076c <HAL_RCC_OscConfig+0x2a8>)
 800052c:	039b      	lsls	r3, r3, #14
 800052e:	d507      	bpl.n	8000540 <HAL_RCC_OscConfig+0x7c>
      {
        if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8000530:	f000 fb02 	bl	8000b38 <HAL_GetTick>
 8000534:	1bc0      	subs	r0, r0, r7
 8000536:	f5b0 7ffa 	cmp.w	r0, #500	; 0x1f4
 800053a:	d9f5      	bls.n	8000528 <HAL_RCC_OscConfig+0x64>
        {
          return HAL_TIMEOUT;
 800053c:	2003      	movs	r0, #3
 800053e:	e194      	b.n	800086a <HAL_RCC_OscConfig+0x3a6>
        }
      }
      
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8000540:	682b      	ldr	r3, [r5, #0]
 8000542:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8000546:	602b      	str	r3, [r5, #0]
 8000548:	6863      	ldr	r3, [r4, #4]
 800054a:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800054e:	d103      	bne.n	8000558 <HAL_RCC_OscConfig+0x94>
 8000550:	682b      	ldr	r3, [r5, #0]
 8000552:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8000556:	e005      	b.n	8000564 <HAL_RCC_OscConfig+0xa0>
 8000558:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 800055c:	d108      	bne.n	8000570 <HAL_RCC_OscConfig+0xac>
 800055e:	682b      	ldr	r3, [r5, #0]
 8000560:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8000564:	602b      	str	r3, [r5, #0]
 8000566:	682b      	ldr	r3, [r5, #0]
 8000568:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800056c:	602b      	str	r3, [r5, #0]
 800056e:	e008      	b.n	8000582 <HAL_RCC_OscConfig+0xbe>
 8000570:	682a      	ldr	r2, [r5, #0]
 8000572:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8000576:	602a      	str	r2, [r5, #0]
 8000578:	682a      	ldr	r2, [r5, #0]
 800057a:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 800057e:	602a      	str	r2, [r5, #0]
      
      /* Check the HSE State */
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 8000580:	b16b      	cbz	r3, 800059e <HAL_RCC_OscConfig+0xda>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8000582:	f000 fad9 	bl	8000b38 <HAL_GetTick>
        
        /* Wait till HSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8000586:	4d79      	ldr	r5, [pc, #484]	; (800076c <HAL_RCC_OscConfig+0x2a8>)
      
      /* Check the HSE State */
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8000588:	4606      	mov	r6, r0
        
        /* Wait till HSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800058a:	682b      	ldr	r3, [r5, #0]
 800058c:	039f      	lsls	r7, r3, #14
 800058e:	d49f      	bmi.n	80004d0 <HAL_RCC_OscConfig+0xc>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8000590:	f000 fad2 	bl	8000b38 <HAL_GetTick>
 8000594:	1b80      	subs	r0, r0, r6
 8000596:	f5b0 7ffa 	cmp.w	r0, #500	; 0x1f4
 800059a:	d9f6      	bls.n	800058a <HAL_RCC_OscConfig+0xc6>
 800059c:	e7ce      	b.n	800053c <HAL_RCC_OscConfig+0x78>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800059e:	f000 facb 	bl	8000b38 <HAL_GetTick>
 80005a2:	4606      	mov	r6, r0
        
        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 80005a4:	682b      	ldr	r3, [r5, #0]
 80005a6:	0398      	lsls	r0, r3, #14
 80005a8:	d592      	bpl.n	80004d0 <HAL_RCC_OscConfig+0xc>
        {
           if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 80005aa:	f000 fac5 	bl	8000b38 <HAL_GetTick>
 80005ae:	1b80      	subs	r0, r0, r6
 80005b0:	f5b0 7ffa 	cmp.w	r0, #500	; 0x1f4
 80005b4:	d9f6      	bls.n	80005a4 <HAL_RCC_OscConfig+0xe0>
 80005b6:	e7c1      	b.n	800053c <HAL_RCC_OscConfig+0x78>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI) 
 80005b8:	4b6c      	ldr	r3, [pc, #432]	; (800076c <HAL_RCC_OscConfig+0x2a8>)
 80005ba:	689a      	ldr	r2, [r3, #8]
 80005bc:	f012 0f0c 	tst.w	r2, #12
 80005c0:	d007      	beq.n	80005d2 <HAL_RCC_OscConfig+0x10e>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 80005c2:	689a      	ldr	r2, [r3, #8]
 80005c4:	f002 020c 	and.w	r2, r2, #12
 80005c8:	2a08      	cmp	r2, #8
 80005ca:	d117      	bne.n	80005fc <HAL_RCC_OscConfig+0x138>
 80005cc:	685b      	ldr	r3, [r3, #4]
 80005ce:	0259      	lsls	r1, r3, #9
 80005d0:	d414      	bmi.n	80005fc <HAL_RCC_OscConfig+0x138>
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 80005d2:	4b66      	ldr	r3, [pc, #408]	; (800076c <HAL_RCC_OscConfig+0x2a8>)
 80005d4:	681a      	ldr	r2, [r3, #0]
 80005d6:	0792      	lsls	r2, r2, #30
 80005d8:	d502      	bpl.n	80005e0 <HAL_RCC_OscConfig+0x11c>
 80005da:	68e2      	ldr	r2, [r4, #12]
 80005dc:	2a01      	cmp	r2, #1
 80005de:	d190      	bne.n	8000502 <HAL_RCC_OscConfig+0x3e>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80005e0:	681a      	ldr	r2, [r3, #0]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80005e2:	21f8      	movs	r1, #248	; 0xf8
 80005e4:	fa91 f1a1 	rbit	r1, r1
 80005e8:	6920      	ldr	r0, [r4, #16]
 80005ea:	fab1 f181 	clz	r1, r1
 80005ee:	f022 02f8 	bic.w	r2, r2, #248	; 0xf8
 80005f2:	fa00 f101 	lsl.w	r1, r0, r1
 80005f6:	430a      	orrs	r2, r1
 80005f8:	601a      	str	r2, [r3, #0]
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI) 
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 80005fa:	e031      	b.n	8000660 <HAL_RCC_OscConfig+0x19c>
      }
    }
    else
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 80005fc:	68e3      	ldr	r3, [r4, #12]
 80005fe:	4d5b      	ldr	r5, [pc, #364]	; (800076c <HAL_RCC_OscConfig+0x2a8>)
 8000600:	b1f3      	cbz	r3, 8000640 <HAL_RCC_OscConfig+0x17c>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 8000602:	682b      	ldr	r3, [r5, #0]
 8000604:	f043 0301 	orr.w	r3, r3, #1
 8000608:	602b      	str	r3, [r5, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800060a:	f000 fa95 	bl	8000b38 <HAL_GetTick>
 800060e:	4606      	mov	r6, r0

        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8000610:	682b      	ldr	r3, [r5, #0]
 8000612:	4856      	ldr	r0, [pc, #344]	; (800076c <HAL_RCC_OscConfig+0x2a8>)
 8000614:	079f      	lsls	r7, r3, #30
 8000616:	d405      	bmi.n	8000624 <HAL_RCC_OscConfig+0x160>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8000618:	f000 fa8e 	bl	8000b38 <HAL_GetTick>
 800061c:	1b80      	subs	r0, r0, r6
 800061e:	2864      	cmp	r0, #100	; 0x64
 8000620:	d9f6      	bls.n	8000610 <HAL_RCC_OscConfig+0x14c>
 8000622:	e78b      	b.n	800053c <HAL_RCC_OscConfig+0x78>
            return HAL_TIMEOUT;
          }
        }
                
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8000624:	6803      	ldr	r3, [r0, #0]
 8000626:	22f8      	movs	r2, #248	; 0xf8
 8000628:	fa92 f2a2 	rbit	r2, r2
 800062c:	6921      	ldr	r1, [r4, #16]
 800062e:	fab2 f282 	clz	r2, r2
 8000632:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 8000636:	fa01 f202 	lsl.w	r2, r1, r2
 800063a:	4313      	orrs	r3, r2
 800063c:	6003      	str	r3, [r0, #0]
 800063e:	e00f      	b.n	8000660 <HAL_RCC_OscConfig+0x19c>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 8000640:	682b      	ldr	r3, [r5, #0]
 8000642:	f023 0301 	bic.w	r3, r3, #1
 8000646:	602b      	str	r3, [r5, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8000648:	f000 fa76 	bl	8000b38 <HAL_GetTick>
 800064c:	4606      	mov	r6, r0
      
        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 800064e:	682b      	ldr	r3, [r5, #0]
 8000650:	0799      	lsls	r1, r3, #30
 8000652:	d505      	bpl.n	8000660 <HAL_RCC_OscConfig+0x19c>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8000654:	f000 fa70 	bl	8000b38 <HAL_GetTick>
 8000658:	1b80      	subs	r0, r0, r6
 800065a:	2864      	cmp	r0, #100	; 0x64
 800065c:	d9f7      	bls.n	800064e <HAL_RCC_OscConfig+0x18a>
 800065e:	e76d      	b.n	800053c <HAL_RCC_OscConfig+0x78>
        } 
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8000660:	6823      	ldr	r3, [r4, #0]
 8000662:	071a      	lsls	r2, r3, #28
 8000664:	d403      	bmi.n	800066e <HAL_RCC_OscConfig+0x1aa>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8000666:	6823      	ldr	r3, [r4, #0]
 8000668:	075b      	lsls	r3, r3, #29
 800066a:	d569      	bpl.n	8000740 <HAL_RCC_OscConfig+0x27c>
 800066c:	e022      	b.n	80006b4 <HAL_RCC_OscConfig+0x1f0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 800066e:	6963      	ldr	r3, [r4, #20]
 8000670:	4d3e      	ldr	r5, [pc, #248]	; (800076c <HAL_RCC_OscConfig+0x2a8>)
 8000672:	b17b      	cbz	r3, 8000694 <HAL_RCC_OscConfig+0x1d0>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 8000674:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 8000676:	f043 0301 	orr.w	r3, r3, #1
 800067a:	676b      	str	r3, [r5, #116]	; 0x74
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800067c:	f000 fa5c 	bl	8000b38 <HAL_GetTick>
 8000680:	4606      	mov	r6, r0
      
      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8000682:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 8000684:	079f      	lsls	r7, r3, #30
 8000686:	d4ee      	bmi.n	8000666 <HAL_RCC_OscConfig+0x1a2>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8000688:	f000 fa56 	bl	8000b38 <HAL_GetTick>
 800068c:	1b80      	subs	r0, r0, r6
 800068e:	2864      	cmp	r0, #100	; 0x64
 8000690:	d9f7      	bls.n	8000682 <HAL_RCC_OscConfig+0x1be>
 8000692:	e753      	b.n	800053c <HAL_RCC_OscConfig+0x78>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 8000694:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 8000696:	f023 0301 	bic.w	r3, r3, #1
 800069a:	676b      	str	r3, [r5, #116]	; 0x74
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800069c:	f000 fa4c 	bl	8000b38 <HAL_GetTick>
 80006a0:	4606      	mov	r6, r0
      
      /* Wait till LSI is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 80006a2:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 80006a4:	0798      	lsls	r0, r3, #30
 80006a6:	d5de      	bpl.n	8000666 <HAL_RCC_OscConfig+0x1a2>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 80006a8:	f000 fa46 	bl	8000b38 <HAL_GetTick>
 80006ac:	1b80      	subs	r0, r0, r6
 80006ae:	2864      	cmp	r0, #100	; 0x64
 80006b0:	d9f7      	bls.n	80006a2 <HAL_RCC_OscConfig+0x1de>
 80006b2:	e743      	b.n	800053c <HAL_RCC_OscConfig+0x78>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
    
    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 80006b4:	2300      	movs	r3, #0
    
    /* Enable write access to Backup domain */
    PWR->CR1 |= PWR_CR1_DBP;
 80006b6:	4d2e      	ldr	r5, [pc, #184]	; (8000770 <HAL_RCC_OscConfig+0x2ac>)
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
    
    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 80006b8:	9301      	str	r3, [sp, #4]
 80006ba:	4b2c      	ldr	r3, [pc, #176]	; (800076c <HAL_RCC_OscConfig+0x2a8>)
 80006bc:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80006be:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80006c2:	641a      	str	r2, [r3, #64]	; 0x40
 80006c4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80006c6:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80006ca:	9301      	str	r3, [sp, #4]
 80006cc:	9b01      	ldr	r3, [sp, #4]
    
    /* Enable write access to Backup domain */
    PWR->CR1 |= PWR_CR1_DBP;
 80006ce:	682b      	ldr	r3, [r5, #0]
 80006d0:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80006d4:	602b      	str	r3, [r5, #0]
    
    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
 80006d6:	f000 fa2f 	bl	8000b38 <HAL_GetTick>
 80006da:	4606      	mov	r6, r0
    
    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
 80006dc:	682b      	ldr	r3, [r5, #0]
 80006de:	05d9      	lsls	r1, r3, #23
 80006e0:	d531      	bpl.n	8000746 <HAL_RCC_OscConfig+0x282>
        return HAL_TIMEOUT;
      }      
    }
    
    /* Reset LSEON and LSEBYP bits before configuring the LSE ----------------*/
    __HAL_RCC_LSE_CONFIG(RCC_LSE_OFF);
 80006e2:	4d22      	ldr	r5, [pc, #136]	; (800076c <HAL_RCC_OscConfig+0x2a8>)
    tickstart = HAL_GetTick();
    
    /* Wait till LSE is ready */  
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
    {
      if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80006e4:	f241 3888 	movw	r8, #5000	; 0x1388
        return HAL_TIMEOUT;
      }      
    }
    
    /* Reset LSEON and LSEBYP bits before configuring the LSE ----------------*/
    __HAL_RCC_LSE_CONFIG(RCC_LSE_OFF);
 80006e8:	6f2b      	ldr	r3, [r5, #112]	; 0x70
    
    /* Get Start Tick*/
    tickstart = HAL_GetTick();
    
    /* Wait till LSE is ready */  
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 80006ea:	462e      	mov	r6, r5
        return HAL_TIMEOUT;
      }      
    }
    
    /* Reset LSEON and LSEBYP bits before configuring the LSE ----------------*/
    __HAL_RCC_LSE_CONFIG(RCC_LSE_OFF);
 80006ec:	f023 0301 	bic.w	r3, r3, #1
 80006f0:	672b      	str	r3, [r5, #112]	; 0x70
 80006f2:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 80006f4:	f023 0304 	bic.w	r3, r3, #4
 80006f8:	672b      	str	r3, [r5, #112]	; 0x70
 80006fa:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 80006fc:	f023 0301 	bic.w	r3, r3, #1
 8000700:	672b      	str	r3, [r5, #112]	; 0x70
    
    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8000702:	f000 fa19 	bl	8000b38 <HAL_GetTick>
 8000706:	4607      	mov	r7, r0
    
    /* Wait till LSE is ready */  
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8000708:	6f33      	ldr	r3, [r6, #112]	; 0x70
 800070a:	4d18      	ldr	r5, [pc, #96]	; (800076c <HAL_RCC_OscConfig+0x2a8>)
 800070c:	079a      	lsls	r2, r3, #30
 800070e:	d420      	bmi.n	8000752 <HAL_RCC_OscConfig+0x28e>
        return HAL_TIMEOUT;
      }    
    } 
    
    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8000710:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8000712:	f023 0301 	bic.w	r3, r3, #1
 8000716:	672b      	str	r3, [r5, #112]	; 0x70
 8000718:	68a3      	ldr	r3, [r4, #8]
 800071a:	2b01      	cmp	r3, #1
 800071c:	d11f      	bne.n	800075e <HAL_RCC_OscConfig+0x29a>
 800071e:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8000720:	f023 0304 	bic.w	r3, r3, #4
 8000724:	672b      	str	r3, [r5, #112]	; 0x70
 8000726:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8000728:	f043 0301 	orr.w	r3, r3, #1
 800072c:	672b      	str	r3, [r5, #112]	; 0x70
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800072e:	f000 fa03 	bl	8000b38 <HAL_GetTick>
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8000732:	4d0e      	ldr	r5, [pc, #56]	; (800076c <HAL_RCC_OscConfig+0x2a8>)
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8000734:	4606      	mov	r6, r0
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8000736:	f241 3788 	movw	r7, #5000	; 0x1388
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800073a:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 800073c:	079b      	lsls	r3, r3, #30
 800073e:	d523      	bpl.n	8000788 <HAL_RCC_OscConfig+0x2c4>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 8000740:	69a2      	ldr	r2, [r4, #24]
 8000742:	bbaa      	cbnz	r2, 80007b0 <HAL_RCC_OscConfig+0x2ec>
 8000744:	e077      	b.n	8000836 <HAL_RCC_OscConfig+0x372>
    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
    
    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
    {
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 8000746:	f000 f9f7 	bl	8000b38 <HAL_GetTick>
 800074a:	1b80      	subs	r0, r0, r6
 800074c:	2864      	cmp	r0, #100	; 0x64
 800074e:	d9c5      	bls.n	80006dc <HAL_RCC_OscConfig+0x218>
 8000750:	e6f4      	b.n	800053c <HAL_RCC_OscConfig+0x78>
    tickstart = HAL_GetTick();
    
    /* Wait till LSE is ready */  
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
    {
      if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8000752:	f000 f9f1 	bl	8000b38 <HAL_GetTick>
 8000756:	1bc0      	subs	r0, r0, r7
 8000758:	4540      	cmp	r0, r8
 800075a:	d9d5      	bls.n	8000708 <HAL_RCC_OscConfig+0x244>
 800075c:	e6ee      	b.n	800053c <HAL_RCC_OscConfig+0x78>
        return HAL_TIMEOUT;
      }    
    } 
    
    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800075e:	2b05      	cmp	r3, #5
 8000760:	d108      	bne.n	8000774 <HAL_RCC_OscConfig+0x2b0>
 8000762:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8000764:	f043 0304 	orr.w	r3, r3, #4
 8000768:	e7dc      	b.n	8000724 <HAL_RCC_OscConfig+0x260>
 800076a:	bf00      	nop
 800076c:	40023800 	.word	0x40023800
 8000770:	40007000 	.word	0x40007000
 8000774:	6f2a      	ldr	r2, [r5, #112]	; 0x70
 8000776:	f022 0204 	bic.w	r2, r2, #4
 800077a:	672a      	str	r2, [r5, #112]	; 0x70
 800077c:	6f2a      	ldr	r2, [r5, #112]	; 0x70
 800077e:	f022 0201 	bic.w	r2, r2, #1
 8000782:	672a      	str	r2, [r5, #112]	; 0x70
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 8000784:	b133      	cbz	r3, 8000794 <HAL_RCC_OscConfig+0x2d0>
 8000786:	e7d2      	b.n	800072e <HAL_RCC_OscConfig+0x26a>
      tickstart = HAL_GetTick();
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8000788:	f000 f9d6 	bl	8000b38 <HAL_GetTick>
 800078c:	1b80      	subs	r0, r0, r6
 800078e:	42b8      	cmp	r0, r7
 8000790:	d9d3      	bls.n	800073a <HAL_RCC_OscConfig+0x276>
 8000792:	e6d3      	b.n	800053c <HAL_RCC_OscConfig+0x78>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8000794:	f000 f9d0 	bl	8000b38 <HAL_GetTick>
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8000798:	f241 3788 	movw	r7, #5000	; 0x1388
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800079c:	4606      	mov	r6, r0
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800079e:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 80007a0:	0798      	lsls	r0, r3, #30
 80007a2:	d5cd      	bpl.n	8000740 <HAL_RCC_OscConfig+0x27c>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80007a4:	f000 f9c8 	bl	8000b38 <HAL_GetTick>
 80007a8:	1b80      	subs	r0, r0, r6
 80007aa:	42b8      	cmp	r0, r7
 80007ac:	d9f7      	bls.n	800079e <HAL_RCC_OscConfig+0x2da>
 80007ae:	e6c5      	b.n	800053c <HAL_RCC_OscConfig+0x78>
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 80007b0:	4d2f      	ldr	r5, [pc, #188]	; (8000870 <HAL_RCC_OscConfig+0x3ac>)
 80007b2:	68ab      	ldr	r3, [r5, #8]
 80007b4:	f003 030c 	and.w	r3, r3, #12
 80007b8:	2b08      	cmp	r3, #8
 80007ba:	f43f aea2 	beq.w	8000502 <HAL_RCC_OscConfig+0x3e>
        assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
        
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 80007be:	682b      	ldr	r3, [r5, #0]
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
    { 
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 80007c0:	2a02      	cmp	r2, #2
        assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
        
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 80007c2:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 80007c6:	602b      	str	r3, [r5, #0]
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
    { 
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 80007c8:	d143      	bne.n	8000852 <HAL_RCC_OscConfig+0x38e>
        
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
        
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80007ca:	f000 f9b5 	bl	8000b38 <HAL_GetTick>
 80007ce:	4607      	mov	r7, r0
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80007d0:	682b      	ldr	r3, [r5, #0]
 80007d2:	4e27      	ldr	r6, [pc, #156]	; (8000870 <HAL_RCC_OscConfig+0x3ac>)
 80007d4:	0199      	lsls	r1, r3, #6
 80007d6:	d430      	bmi.n	800083a <HAL_RCC_OscConfig+0x376>
 80007d8:	f647 72c0 	movw	r2, #32704	; 0x7fc0
 80007dc:	fa92 f2a2 	rbit	r2, r2
 80007e0:	f44f 3340 	mov.w	r3, #196608	; 0x30000
            return HAL_TIMEOUT;
          }
        }
        
        /* Configure the main PLL clock source, multiplication and division factors. */
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 80007e4:	fab2 f082 	clz	r0, r2
 80007e8:	fa93 f3a3 	rbit	r3, r3
 80007ec:	f04f 6270 	mov.w	r2, #251658240	; 0xf000000
 80007f0:	fab3 f583 	clz	r5, r3
 80007f4:	fa92 f2a2 	rbit	r2, r2
 80007f8:	6a23      	ldr	r3, [r4, #32]
 80007fa:	fab2 f182 	clz	r1, r2
 80007fe:	69e7      	ldr	r7, [r4, #28]
 8000800:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8000802:	431f      	orrs	r7, r3
 8000804:	4082      	lsls	r2, r0
 8000806:	f047 5300 	orr.w	r3, r7, #536870912	; 0x20000000
 800080a:	ea43 0002 	orr.w	r0, r3, r2
 800080e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8000810:	085a      	lsrs	r2, r3, #1
 8000812:	3a01      	subs	r2, #1
 8000814:	fa02 f305 	lsl.w	r3, r2, r5
 8000818:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800081a:	4303      	orrs	r3, r0
 800081c:	408a      	lsls	r2, r1
 800081e:	4313      	orrs	r3, r2
 8000820:	6073      	str	r3, [r6, #4]
                             RCC_OscInitStruct->PLL.PLLM,
                             RCC_OscInitStruct->PLL.PLLN,
                             RCC_OscInitStruct->PLL.PLLP,
                             RCC_OscInitStruct->PLL.PLLQ);
        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 8000822:	6833      	ldr	r3, [r6, #0]
 8000824:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8000828:	6033      	str	r3, [r6, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800082a:	f000 f985 	bl	8000b38 <HAL_GetTick>
 800082e:	4604      	mov	r4, r0
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8000830:	6833      	ldr	r3, [r6, #0]
 8000832:	019a      	lsls	r2, r3, #6
 8000834:	d507      	bpl.n	8000846 <HAL_RCC_OscConfig+0x382>
    else
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
 8000836:	2000      	movs	r0, #0
 8000838:	e017      	b.n	800086a <HAL_RCC_OscConfig+0x3a6>
        tickstart = HAL_GetTick();
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800083a:	f000 f97d 	bl	8000b38 <HAL_GetTick>
 800083e:	1bc0      	subs	r0, r0, r7
 8000840:	2864      	cmp	r0, #100	; 0x64
 8000842:	d9c5      	bls.n	80007d0 <HAL_RCC_OscConfig+0x30c>
 8000844:	e67a      	b.n	800053c <HAL_RCC_OscConfig+0x78>
        tickstart = HAL_GetTick();
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8000846:	f000 f977 	bl	8000b38 <HAL_GetTick>
 800084a:	1b00      	subs	r0, r0, r4
 800084c:	2864      	cmp	r0, #100	; 0x64
 800084e:	d9ef      	bls.n	8000830 <HAL_RCC_OscConfig+0x36c>
 8000850:	e674      	b.n	800053c <HAL_RCC_OscConfig+0x78>
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8000852:	f000 f971 	bl	8000b38 <HAL_GetTick>
 8000856:	4604      	mov	r4, r0
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8000858:	682b      	ldr	r3, [r5, #0]
 800085a:	019b      	lsls	r3, r3, #6
 800085c:	d5eb      	bpl.n	8000836 <HAL_RCC_OscConfig+0x372>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800085e:	f000 f96b 	bl	8000b38 <HAL_GetTick>
 8000862:	1b00      	subs	r0, r0, r4
 8000864:	2864      	cmp	r0, #100	; 0x64
 8000866:	d9f7      	bls.n	8000858 <HAL_RCC_OscConfig+0x394>
 8000868:	e668      	b.n	800053c <HAL_RCC_OscConfig+0x78>
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
}
 800086a:	b002      	add	sp, #8
 800086c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000870:	40023800 	.word	0x40023800

08000874 <HAL_RCC_ClockConfig>:
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
     must be correctly programmed according to the frequency of the CPU clock 
     (HCLK) and the supply voltage of the device. */
  
  /* Increasing the CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8000874:	4a6c      	ldr	r2, [pc, #432]	; (8000a28 <HAL_RCC_ClockConfig+0x1b4>)
 8000876:	6813      	ldr	r3, [r2, #0]
 8000878:	f003 030f 	and.w	r3, r3, #15
 800087c:	428b      	cmp	r3, r1
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 800087e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8000882:	4604      	mov	r4, r0
 8000884:	460d      	mov	r5, r1
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
     must be correctly programmed according to the frequency of the CPU clock 
     (HCLK) and the supply voltage of the device. */
  
  /* Increasing the CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8000886:	d266      	bcs.n	8000956 <HAL_RCC_ClockConfig+0xe2>
  {    
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8000888:	6813      	ldr	r3, [r2, #0]
 800088a:	f023 030f 	bic.w	r3, r3, #15
 800088e:	430b      	orrs	r3, r1
 8000890:	6013      	str	r3, [r2, #0]
    
    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 8000892:	6813      	ldr	r3, [r2, #0]
 8000894:	f003 030f 	and.w	r3, r3, #15
 8000898:	4299      	cmp	r1, r3
 800089a:	d002      	beq.n	80008a2 <HAL_RCC_ClockConfig+0x2e>
    {
      return HAL_ERROR;
 800089c:	2001      	movs	r0, #1
 800089e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }

    /*-------------------------- HCLK Configuration --------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 80008a2:	6801      	ldr	r1, [r0, #0]
 80008a4:	078f      	lsls	r7, r1, #30
 80008a6:	d506      	bpl.n	80008b6 <HAL_RCC_ClockConfig+0x42>
    {
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 80008a8:	4860      	ldr	r0, [pc, #384]	; (8000a2c <HAL_RCC_ClockConfig+0x1b8>)
 80008aa:	6883      	ldr	r3, [r0, #8]
 80008ac:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 80008b0:	68a3      	ldr	r3, [r4, #8]
 80008b2:	4313      	orrs	r3, r2
 80008b4:	6083      	str	r3, [r0, #8]
    }

    /*------------------------- SYSCLK Configuration ---------------------------*/ 
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 80008b6:	07ce      	lsls	r6, r1, #31
 80008b8:	d40b      	bmi.n	80008d2 <HAL_RCC_ClockConfig+0x5e>
      return HAL_ERROR;
    }
 }

  /*-------------------------- PCLK1 Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 80008ba:	6821      	ldr	r1, [r4, #0]
 80008bc:	074d      	lsls	r5, r1, #29
 80008be:	f140 80a3 	bpl.w	8000a08 <HAL_RCC_ClockConfig+0x194>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 80008c2:	485a      	ldr	r0, [pc, #360]	; (8000a2c <HAL_RCC_ClockConfig+0x1b8>)
 80008c4:	6883      	ldr	r3, [r0, #8]
 80008c6:	f423 52e0 	bic.w	r2, r3, #7168	; 0x1c00
 80008ca:	68e3      	ldr	r3, [r4, #12]
 80008cc:	4313      	orrs	r3, r2
 80008ce:	6083      	str	r3, [r0, #8]
 80008d0:	e09a      	b.n	8000a08 <HAL_RCC_ClockConfig+0x194>
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
    {    
      assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
      
      /* HSE is selected as System Clock Source */
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80008d2:	6862      	ldr	r2, [r4, #4]
 80008d4:	4b55      	ldr	r3, [pc, #340]	; (8000a2c <HAL_RCC_ClockConfig+0x1b8>)
 80008d6:	2a01      	cmp	r2, #1
      {
        /* Check the HSE ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80008d8:	6819      	ldr	r1, [r3, #0]
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
    {    
      assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
      
      /* HSE is selected as System Clock Source */
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80008da:	d102      	bne.n	80008e2 <HAL_RCC_ClockConfig+0x6e>
      {
        /* Check the HSE ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80008dc:	f411 3f00 	tst.w	r1, #131072	; 0x20000
 80008e0:	e006      	b.n	80008f0 <HAL_RCC_ClockConfig+0x7c>
        {
          return HAL_ERROR;
        }
      }
      /* PLL is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 80008e2:	2a02      	cmp	r2, #2
 80008e4:	d102      	bne.n	80008ec <HAL_RCC_ClockConfig+0x78>
      {
        /* Check the PLL ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 80008e6:	f011 7f00 	tst.w	r1, #33554432	; 0x2000000
 80008ea:	e001      	b.n	80008f0 <HAL_RCC_ClockConfig+0x7c>
      }
      /* HSI is selected as System Clock Source */
      else
      {
        /* Check the HSI ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80008ec:	f011 0f02 	tst.w	r1, #2
 80008f0:	d0d4      	beq.n	800089c <HAL_RCC_ClockConfig+0x28>
        {
          return HAL_ERROR;
        }
      }

      __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 80008f2:	6899      	ldr	r1, [r3, #8]
      
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 80008f4:	f241 3788 	movw	r7, #5000	; 0x1388
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 80008f8:	4e4c      	ldr	r6, [pc, #304]	; (8000a2c <HAL_RCC_ClockConfig+0x1b8>)
        {
          return HAL_ERROR;
        }
      }

      __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 80008fa:	f021 0103 	bic.w	r1, r1, #3
 80008fe:	430a      	orrs	r2, r1
 8000900:	609a      	str	r2, [r3, #8]
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8000902:	f000 f919 	bl	8000b38 <HAL_GetTick>
      
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8000906:	6863      	ldr	r3, [r4, #4]
        }
      }

      __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8000908:	4605      	mov	r5, r0
      
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800090a:	2b01      	cmp	r3, #1
 800090c:	d10c      	bne.n	8000928 <HAL_RCC_ClockConfig+0xb4>
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 800090e:	68b3      	ldr	r3, [r6, #8]
 8000910:	f003 030c 	and.w	r3, r3, #12
 8000914:	2b04      	cmp	r3, #4
 8000916:	d0d0      	beq.n	80008ba <HAL_RCC_ClockConfig+0x46>
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8000918:	f000 f90e 	bl	8000b38 <HAL_GetTick>
 800091c:	1b40      	subs	r0, r0, r5
 800091e:	42b8      	cmp	r0, r7
 8000920:	d9f5      	bls.n	800090e <HAL_RCC_ClockConfig+0x9a>
          {
            return HAL_TIMEOUT;
 8000922:	2003      	movs	r0, #3
 8000924:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8000928:	2b02      	cmp	r3, #2
 800092a:	d10f      	bne.n	800094c <HAL_RCC_ClockConfig+0xd8>
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 800092c:	68b3      	ldr	r3, [r6, #8]
 800092e:	f003 030c 	and.w	r3, r3, #12
 8000932:	2b08      	cmp	r3, #8
 8000934:	d0c1      	beq.n	80008ba <HAL_RCC_ClockConfig+0x46>
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8000936:	f000 f8ff 	bl	8000b38 <HAL_GetTick>
 800093a:	1b40      	subs	r0, r0, r5
 800093c:	42b8      	cmp	r0, r7
 800093e:	d9f5      	bls.n	800092c <HAL_RCC_ClockConfig+0xb8>
 8000940:	e7ef      	b.n	8000922 <HAL_RCC_ClockConfig+0xae>
      }
      else
      {
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8000942:	f000 f8f9 	bl	8000b38 <HAL_GetTick>
 8000946:	1b40      	subs	r0, r0, r5
 8000948:	42b8      	cmp	r0, r7
 800094a:	d8ea      	bhi.n	8000922 <HAL_RCC_ClockConfig+0xae>
          }
        }
      }
      else
      {
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 800094c:	68b3      	ldr	r3, [r6, #8]
 800094e:	f013 0f0c 	tst.w	r3, #12
 8000952:	d1f6      	bne.n	8000942 <HAL_RCC_ClockConfig+0xce>
 8000954:	e7b1      	b.n	80008ba <HAL_RCC_ClockConfig+0x46>
  }
  /* Decreasing the CPU frequency */
  else
  {
    /*-------------------------- HCLK Configuration --------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8000956:	6801      	ldr	r1, [r0, #0]
 8000958:	0788      	lsls	r0, r1, #30
 800095a:	d506      	bpl.n	800096a <HAL_RCC_ClockConfig+0xf6>
    {
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 800095c:	4833      	ldr	r0, [pc, #204]	; (8000a2c <HAL_RCC_ClockConfig+0x1b8>)
 800095e:	6883      	ldr	r3, [r0, #8]
 8000960:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 8000964:	68a3      	ldr	r3, [r4, #8]
 8000966:	4313      	orrs	r3, r2
 8000968:	6083      	str	r3, [r0, #8]
    }

    /*------------------------- SYSCLK Configuration -------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 800096a:	07ca      	lsls	r2, r1, #31
 800096c:	d40b      	bmi.n	8000986 <HAL_RCC_ClockConfig+0x112>
        }
      }
    }
    
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 800096e:	4a2e      	ldr	r2, [pc, #184]	; (8000a28 <HAL_RCC_ClockConfig+0x1b4>)
 8000970:	6813      	ldr	r3, [r2, #0]
 8000972:	f023 030f 	bic.w	r3, r3, #15
 8000976:	432b      	orrs	r3, r5
 8000978:	6013      	str	r3, [r2, #0]
    
    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 800097a:	6813      	ldr	r3, [r2, #0]
 800097c:	f003 030f 	and.w	r3, r3, #15
 8000980:	429d      	cmp	r5, r3
 8000982:	d18b      	bne.n	800089c <HAL_RCC_ClockConfig+0x28>
 8000984:	e799      	b.n	80008ba <HAL_RCC_ClockConfig+0x46>
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
    {    
      assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
      
      /* HSE is selected as System Clock Source */
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8000986:	6862      	ldr	r2, [r4, #4]
 8000988:	4b28      	ldr	r3, [pc, #160]	; (8000a2c <HAL_RCC_ClockConfig+0x1b8>)
 800098a:	2a01      	cmp	r2, #1
      {
        /* Check the HSE ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800098c:	6819      	ldr	r1, [r3, #0]
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
    {    
      assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
      
      /* HSE is selected as System Clock Source */
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800098e:	d102      	bne.n	8000996 <HAL_RCC_ClockConfig+0x122>
      {
        /* Check the HSE ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8000990:	f411 3f00 	tst.w	r1, #131072	; 0x20000
 8000994:	e006      	b.n	80009a4 <HAL_RCC_ClockConfig+0x130>
        {
          return HAL_ERROR;
        }
      }
      /* PLL is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8000996:	2a02      	cmp	r2, #2
 8000998:	d102      	bne.n	80009a0 <HAL_RCC_ClockConfig+0x12c>
      {
        /* Check the PLL ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800099a:	f011 7f00 	tst.w	r1, #33554432	; 0x2000000
 800099e:	e001      	b.n	80009a4 <HAL_RCC_ClockConfig+0x130>
      }
      /* HSI is selected as System Clock Source */
      else
      {
        /* Check the HSI ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80009a0:	f011 0f02 	tst.w	r1, #2
 80009a4:	f43f af7a 	beq.w	800089c <HAL_RCC_ClockConfig+0x28>
        {
          return HAL_ERROR;
        }
      }
      __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 80009a8:	6899      	ldr	r1, [r3, #8]
      
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 80009aa:	f241 3888 	movw	r8, #5000	; 0x1388
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 80009ae:	4f1f      	ldr	r7, [pc, #124]	; (8000a2c <HAL_RCC_ClockConfig+0x1b8>)
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
        {
          return HAL_ERROR;
        }
      }
      __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 80009b0:	f021 0103 	bic.w	r1, r1, #3
 80009b4:	430a      	orrs	r2, r1
 80009b6:	609a      	str	r2, [r3, #8]
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80009b8:	f000 f8be 	bl	8000b38 <HAL_GetTick>
      
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80009bc:	6863      	ldr	r3, [r4, #4]
          return HAL_ERROR;
        }
      }
      __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80009be:	4606      	mov	r6, r0
      
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80009c0:	2b01      	cmp	r3, #1
 80009c2:	d10a      	bne.n	80009da <HAL_RCC_ClockConfig+0x166>
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 80009c4:	68bb      	ldr	r3, [r7, #8]
 80009c6:	f003 030c 	and.w	r3, r3, #12
 80009ca:	2b04      	cmp	r3, #4
 80009cc:	d0cf      	beq.n	800096e <HAL_RCC_ClockConfig+0xfa>
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 80009ce:	f000 f8b3 	bl	8000b38 <HAL_GetTick>
 80009d2:	1b80      	subs	r0, r0, r6
 80009d4:	4540      	cmp	r0, r8
 80009d6:	d9f5      	bls.n	80009c4 <HAL_RCC_ClockConfig+0x150>
 80009d8:	e7a3      	b.n	8000922 <HAL_RCC_ClockConfig+0xae>
          {
            return HAL_TIMEOUT;
          } 
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 80009da:	2b02      	cmp	r3, #2
 80009dc:	d10f      	bne.n	80009fe <HAL_RCC_ClockConfig+0x18a>
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 80009de:	68bb      	ldr	r3, [r7, #8]
 80009e0:	f003 030c 	and.w	r3, r3, #12
 80009e4:	2b08      	cmp	r3, #8
 80009e6:	d0c2      	beq.n	800096e <HAL_RCC_ClockConfig+0xfa>
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 80009e8:	f000 f8a6 	bl	8000b38 <HAL_GetTick>
 80009ec:	1b80      	subs	r0, r0, r6
 80009ee:	4540      	cmp	r0, r8
 80009f0:	d9f5      	bls.n	80009de <HAL_RCC_ClockConfig+0x16a>
 80009f2:	e796      	b.n	8000922 <HAL_RCC_ClockConfig+0xae>
      }
      else
      {
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 80009f4:	f000 f8a0 	bl	8000b38 <HAL_GetTick>
 80009f8:	1b80      	subs	r0, r0, r6
 80009fa:	4540      	cmp	r0, r8
 80009fc:	d891      	bhi.n	8000922 <HAL_RCC_ClockConfig+0xae>
          } 
        }
      }
      else
      {
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 80009fe:	68bb      	ldr	r3, [r7, #8]
 8000a00:	f013 0f0c 	tst.w	r3, #12
 8000a04:	d1f6      	bne.n	80009f4 <HAL_RCC_ClockConfig+0x180>
 8000a06:	e7b2      	b.n	800096e <HAL_RCC_ClockConfig+0xfa>
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
  }
  
  /*-------------------------- PCLK2 Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8000a08:	070b      	lsls	r3, r1, #28
 8000a0a:	d507      	bpl.n	8000a1c <HAL_RCC_ClockConfig+0x1a8>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 8000a0c:	4a07      	ldr	r2, [pc, #28]	; (8000a2c <HAL_RCC_ClockConfig+0x1b8>)
 8000a0e:	6921      	ldr	r1, [r4, #16]
 8000a10:	6893      	ldr	r3, [r2, #8]
 8000a12:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 8000a16:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8000a1a:	6093      	str	r3, [r2, #8]
  }

  /* Configure the source of time base considering new system clocks settings*/
  HAL_InitTick (TICK_INT_PRIORITY);
 8000a1c:	200f      	movs	r0, #15
 8000a1e:	f000 f85f 	bl	8000ae0 <HAL_InitTick>
  
  return HAL_OK;
 8000a22:	2000      	movs	r0, #0
}
 8000a24:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000a28:	40023c00 	.word	0x40023c00
 8000a2c:	40023800 	.word	0x40023800

08000a30 <HAL_RCC_GetSysClockFreq>:
{
  uint32_t pllm = 0, pllvco = 0, pllp = 0;
  uint32_t sysclockfreq = 0;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8000a30:	491b      	ldr	r1, [pc, #108]	; (8000aa0 <HAL_RCC_GetSysClockFreq+0x70>)
 8000a32:	688b      	ldr	r3, [r1, #8]
 8000a34:	f003 030c 	and.w	r3, r3, #12
 8000a38:	2b04      	cmp	r3, #4
 8000a3a:	d02c      	beq.n	8000a96 <HAL_RCC_GetSysClockFreq+0x66>
 8000a3c:	2b08      	cmp	r3, #8
 8000a3e:	d12c      	bne.n	8000a9a <HAL_RCC_GetSysClockFreq+0x6a>
    }
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8000a40:	6848      	ldr	r0, [r1, #4]
 8000a42:	f647 72c0 	movw	r2, #32704	; 0x7fc0
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLCFGR_PLLSRC_HSI)
 8000a46:	684b      	ldr	r3, [r1, #4]
    }
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8000a48:	f000 003f 	and.w	r0, r0, #63	; 0x3f
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLCFGR_PLLSRC_HSI)
 8000a4c:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
      {
        /* HSE used as PLL clock source */
        pllvco = ((HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));
 8000a50:	684b      	ldr	r3, [r1, #4]
 8000a52:	fa92 f2a2 	rbit	r2, r2
 8000a56:	f647 71c0 	movw	r1, #32704	; 0x7fc0
 8000a5a:	fab2 f282 	clz	r2, r2
 8000a5e:	ea01 0103 	and.w	r1, r1, r3
 8000a62:	fa21 f102 	lsr.w	r1, r1, r2
 8000a66:	bf14      	ite	ne
 8000a68:	4a0e      	ldrne	r2, [pc, #56]	; (8000aa4 <HAL_RCC_GetSysClockFreq+0x74>)
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = ((HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));    
 8000a6a:	4a0f      	ldreq	r2, [pc, #60]	; (8000aa8 <HAL_RCC_GetSysClockFreq+0x78>)
 8000a6c:	fbb2 f0f0 	udiv	r0, r2, r0
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> POSITION_VAL(RCC_PLLCFGR_PLLP)) + 1 ) *2);
 8000a70:	4a0b      	ldr	r2, [pc, #44]	; (8000aa0 <HAL_RCC_GetSysClockFreq+0x70>)
        pllvco = ((HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = ((HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));    
 8000a72:	fb00 f301 	mul.w	r3, r0, r1
 8000a76:	f44f 3040 	mov.w	r0, #196608	; 0x30000
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> POSITION_VAL(RCC_PLLCFGR_PLLP)) + 1 ) *2);
 8000a7a:	6852      	ldr	r2, [r2, #4]
 8000a7c:	fa90 f0a0 	rbit	r0, r0
      
      sysclockfreq = pllvco/pllp;
 8000a80:	f402 3240 	and.w	r2, r2, #196608	; 0x30000
      else
      {
        /* HSI used as PLL clock source */
        pllvco = ((HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));    
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> POSITION_VAL(RCC_PLLCFGR_PLLP)) + 1 ) *2);
 8000a84:	fab0 f080 	clz	r0, r0
      
      sysclockfreq = pllvco/pllp;
 8000a88:	fa22 f000 	lsr.w	r0, r2, r0
 8000a8c:	3001      	adds	r0, #1
 8000a8e:	0040      	lsls	r0, r0, #1
 8000a90:	fbb3 f0f0 	udiv	r0, r3, r0
 8000a94:	4770      	bx	lr
      sysclockfreq = HSI_VALUE;
       break;
    }
    case RCC_SYSCLKSOURCE_STATUS_HSE:  /* HSE used as system clock  source */
    {
      sysclockfreq = HSE_VALUE;
 8000a96:	4803      	ldr	r0, [pc, #12]	; (8000aa4 <HAL_RCC_GetSysClockFreq+0x74>)
 8000a98:	4770      	bx	lr
  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
  {
    case RCC_SYSCLKSOURCE_STATUS_HSI:  /* HSI used as system clock source */
    {
      sysclockfreq = HSI_VALUE;
 8000a9a:	4803      	ldr	r0, [pc, #12]	; (8000aa8 <HAL_RCC_GetSysClockFreq+0x78>)
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
 8000a9c:	4770      	bx	lr
 8000a9e:	bf00      	nop
 8000aa0:	40023800 	.word	0x40023800
 8000aa4:	017d7840 	.word	0x017d7840
 8000aa8:	00f42400 	.word	0x00f42400

08000aac <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency 
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 8000aac:	b508      	push	{r3, lr}
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> POSITION_VAL(RCC_CFGR_HPRE)];
 8000aae:	f7ff ffbf 	bl	8000a30 <HAL_RCC_GetSysClockFreq>
 8000ab2:	4b08      	ldr	r3, [pc, #32]	; (8000ad4 <HAL_RCC_GetHCLKFreq+0x28>)
 8000ab4:	22f0      	movs	r2, #240	; 0xf0
 8000ab6:	689b      	ldr	r3, [r3, #8]
 8000ab8:	fa92 f2a2 	rbit	r2, r2
 8000abc:	fab2 f282 	clz	r2, r2
 8000ac0:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8000ac4:	40d3      	lsrs	r3, r2
 8000ac6:	4a04      	ldr	r2, [pc, #16]	; (8000ad8 <HAL_RCC_GetHCLKFreq+0x2c>)
 8000ac8:	5cd3      	ldrb	r3, [r2, r3]
 8000aca:	40d8      	lsrs	r0, r3
 8000acc:	4b03      	ldr	r3, [pc, #12]	; (8000adc <HAL_RCC_GetHCLKFreq+0x30>)
 8000ace:	6018      	str	r0, [r3, #0]
  return SystemCoreClock;
}
 8000ad0:	bd08      	pop	{r3, pc}
 8000ad2:	bf00      	nop
 8000ad4:	40023800 	.word	0x40023800
 8000ad8:	080010a8 	.word	0x080010a8
 8000adc:	20000000 	.word	0x20000000

08000ae0 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8000ae0:	b510      	push	{r4, lr}
 8000ae2:	4604      	mov	r4, r0
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
 8000ae4:	f7ff ffe2 	bl	8000aac <HAL_RCC_GetHCLKFreq>
 8000ae8:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8000aec:	fbb0 f0f3 	udiv	r0, r0, r3
 8000af0:	f000 f978 	bl	8000de4 <HAL_SYSTICK_Config>

  /*Configure the SysTick IRQ priority */
  HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority ,0);
 8000af4:	2200      	movs	r2, #0
 8000af6:	4621      	mov	r1, r4
 8000af8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8000afc:	f000 f93a 	bl	8000d74 <HAL_NVIC_SetPriority>

  /* Return function status */
  return HAL_OK;
}
 8000b00:	2000      	movs	r0, #0
 8000b02:	bd10      	pop	{r4, pc}

08000b04 <HAL_Init>:
  */
HAL_StatusTypeDef HAL_Init(void)
{
  /* Configure Flash prefetch and Instruction cache through ART accelerator */ 
#if (ART_ACCLERATOR_ENABLE != 0)
   __HAL_FLASH_ART_ENABLE();
 8000b04:	4a07      	ldr	r2, [pc, #28]	; (8000b24 <HAL_Init+0x20>)
#endif /* ART_ACCLERATOR_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8000b06:	2003      	movs	r0, #3
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8000b08:	b508      	push	{r3, lr}
  /* Configure Flash prefetch and Instruction cache through ART accelerator */ 
#if (ART_ACCLERATOR_ENABLE != 0)
   __HAL_FLASH_ART_ENABLE();
 8000b0a:	6813      	ldr	r3, [r2, #0]
 8000b0c:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8000b10:	6013      	str	r3, [r2, #0]
#endif /* ART_ACCLERATOR_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8000b12:	f000 f91d 	bl	8000d50 <HAL_NVIC_SetPriorityGrouping>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 8000b16:	200f      	movs	r0, #15
 8000b18:	f7ff ffe2 	bl	8000ae0 <HAL_InitTick>
  
  /* Init the low level hardware */
  HAL_MspInit();
 8000b1c:	f7ff fca1 	bl	8000462 <HAL_MspInit>
  
  /* Return function status */
  return HAL_OK;
}
 8000b20:	2000      	movs	r0, #0
 8000b22:	bd08      	pop	{r3, pc}
 8000b24:	40023c00 	.word	0x40023c00

08000b28 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick++;
 8000b28:	4a02      	ldr	r2, [pc, #8]	; (8000b34 <HAL_IncTick+0xc>)
 8000b2a:	6813      	ldr	r3, [r2, #0]
 8000b2c:	3301      	adds	r3, #1
 8000b2e:	6013      	str	r3, [r2, #0]
 8000b30:	4770      	bx	lr
 8000b32:	bf00      	nop
 8000b34:	2000044c 	.word	0x2000044c

08000b38 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8000b38:	4b01      	ldr	r3, [pc, #4]	; (8000b40 <HAL_GetTick+0x8>)
 8000b3a:	6818      	ldr	r0, [r3, #0]
}
 8000b3c:	4770      	bx	lr
 8000b3e:	bf00      	nop
 8000b40:	2000044c 	.word	0x2000044c

08000b44 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay: specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(__IO uint32_t Delay)
{
 8000b44:	b513      	push	{r0, r1, r4, lr}
 8000b46:	9001      	str	r0, [sp, #4]
  uint32_t tickstart = 0;
  tickstart = HAL_GetTick();
 8000b48:	f7ff fff6 	bl	8000b38 <HAL_GetTick>
 8000b4c:	4604      	mov	r4, r0
  while((HAL_GetTick() - tickstart) < Delay)
 8000b4e:	f7ff fff3 	bl	8000b38 <HAL_GetTick>
 8000b52:	9b01      	ldr	r3, [sp, #4]
 8000b54:	1b00      	subs	r0, r0, r4
 8000b56:	4298      	cmp	r0, r3
 8000b58:	d3f9      	bcc.n	8000b4e <HAL_Delay+0xa>
  {
  }
}
 8000b5a:	b002      	add	sp, #8
 8000b5c:	bd10      	pop	{r4, pc}
	...

08000b60 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8000b60:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
        SYSCFG->EXTICR[position >> 2] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 8000b64:	4f72      	ldr	r7, [pc, #456]	; (8000d30 <HAL_GPIO_Init+0x1d0>)
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8000b66:	b085      	sub	sp, #20
  for(position = 0; position < GPIO_NUMBER; position++)
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01) << position;
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8000b68:	680b      	ldr	r3, [r1, #0]
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0; position < GPIO_NUMBER; position++)
 8000b6a:	2200      	movs	r2, #0
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000b6c:	f8df c1c8 	ldr.w	ip, [pc, #456]	; 8000d38 <HAL_GPIO_Init+0x1d8>
 8000b70:	46be      	mov	lr, r7

        temp = SYSCFG->EXTICR[position >> 2];
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 8000b72:	f8df 81c8 	ldr.w	r8, [pc, #456]	; 8000d3c <HAL_GPIO_Init+0x1dc>
  for(position = 0; position < GPIO_NUMBER; position++)
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01) << position;
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8000b76:	9301      	str	r3, [sp, #4]

  /* Configure the port pins */
  for(position = 0; position < GPIO_NUMBER; position++)
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01) << position;
 8000b78:	2401      	movs	r4, #1
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;

    if(iocurrent == ioposition)
 8000b7a:	9b01      	ldr	r3, [sp, #4]

  /* Configure the port pins */
  for(position = 0; position < GPIO_NUMBER; position++)
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01) << position;
 8000b7c:	4094      	lsls	r4, r2
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;

    if(iocurrent == ioposition)
 8000b7e:	ea34 0303 	bics.w	r3, r4, r3
 8000b82:	f040 80cd 	bne.w	8000d20 <HAL_GPIO_Init+0x1c0>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8000b86:	684d      	ldr	r5, [r1, #4]
 8000b88:	f025 0a10 	bic.w	sl, r5, #16
 8000b8c:	f1ba 0f02 	cmp.w	sl, #2
 8000b90:	d114      	bne.n	8000bbc <HAL_GPIO_Init+0x5c>
 8000b92:	ea4f 09d2 	mov.w	r9, r2, lsr #3
        /* Check the Alternate function parameter */
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3];
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 8000b96:	f002 0b07 	and.w	fp, r2, #7
 8000b9a:	230f      	movs	r3, #15
 8000b9c:	eb00 0989 	add.w	r9, r0, r9, lsl #2
 8000ba0:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
      {
        /* Check the Alternate function parameter */
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3];
 8000ba4:	f8d9 6020 	ldr.w	r6, [r9, #32]
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 8000ba8:	fa03 f30b 	lsl.w	r3, r3, fp
 8000bac:	ea26 0603 	bic.w	r6, r6, r3
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
 8000bb0:	690b      	ldr	r3, [r1, #16]
 8000bb2:	fa03 f30b 	lsl.w	r3, r3, fp
 8000bb6:	4333      	orrs	r3, r6
        GPIOx->AFR[position >> 3] = temp;
 8000bb8:	f8c9 3020 	str.w	r3, [r9, #32]
 8000bbc:	ea4f 0b42 	mov.w	fp, r2, lsl #1
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 8000bc0:	f04f 0903 	mov.w	r9, #3
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
        GPIOx->AFR[position >> 3] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 8000bc4:	6803      	ldr	r3, [r0, #0]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8000bc6:	f005 0603 	and.w	r6, r5, #3
        GPIOx->AFR[position >> 3] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 8000bca:	fa09 f90b 	lsl.w	r9, r9, fp
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
      GPIOx->MODER = temp;

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8000bce:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8000bd2:	fa06 f60b 	lsl.w	r6, r6, fp
        GPIOx->AFR[position >> 3] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 8000bd6:	ea6f 0909 	mvn.w	r9, r9
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
      GPIOx->MODER = temp;

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8000bda:	f1ba 0f01 	cmp.w	sl, #1
        GPIOx->AFR[position >> 3] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 8000bde:	ea03 0309 	and.w	r3, r3, r9
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8000be2:	ea43 0306 	orr.w	r3, r3, r6
      GPIOx->MODER = temp;
 8000be6:	6003      	str	r3, [r0, #0]

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8000be8:	d80f      	bhi.n	8000c0a <HAL_GPIO_Init+0xaa>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR; 
 8000bea:	6883      	ldr	r3, [r0, #8]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
        temp |= (GPIO_Init->Speed << (position * 2));
 8000bec:	68ce      	ldr	r6, [r1, #12]
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR; 
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
 8000bee:	ea09 0303 	and.w	r3, r9, r3
        temp |= (GPIO_Init->Speed << (position * 2));
 8000bf2:	fa06 f60b 	lsl.w	r6, r6, fp
 8000bf6:	431e      	orrs	r6, r3
        GPIOx->OSPEEDR = temp;
 8000bf8:	6086      	str	r6, [r0, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 8000bfa:	f3c5 1600 	ubfx	r6, r5, #4, #1
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
        temp |= (GPIO_Init->Speed << (position * 2));
        GPIOx->OSPEEDR = temp;

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 8000bfe:	6843      	ldr	r3, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 8000c00:	4096      	lsls	r6, r2
        temp |= (GPIO_Init->Speed << (position * 2));
        GPIOx->OSPEEDR = temp;

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 8000c02:	ea23 0304 	bic.w	r3, r3, r4
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 8000c06:	4333      	orrs	r3, r6
        GPIOx->OTYPER = temp;
 8000c08:	6043      	str	r3, [r0, #4]
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
 8000c0a:	68c3      	ldr	r3, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
 8000c0c:	ea09 0903 	and.w	r9, r9, r3
      temp |= ((GPIO_Init->Pull) << (position * 2));
 8000c10:	688b      	ldr	r3, [r1, #8]
 8000c12:	fa03 f30b 	lsl.w	r3, r3, fp
 8000c16:	ea43 0309 	orr.w	r3, r3, r9
      GPIOx->PUPDR = temp;
 8000c1a:	60c3      	str	r3, [r0, #12]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8000c1c:	00eb      	lsls	r3, r5, #3
 8000c1e:	d57f      	bpl.n	8000d20 <HAL_GPIO_Init+0x1c0>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000c20:	2300      	movs	r3, #0
 8000c22:	f022 0903 	bic.w	r9, r2, #3

        temp = SYSCFG->EXTICR[position >> 2];
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 8000c26:	f002 0a03 	and.w	sl, r2, #3
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000c2a:	9303      	str	r3, [sp, #12]
 8000c2c:	f109 4980 	add.w	r9, r9, #1073741824	; 0x40000000
 8000c30:	f8dc 6044 	ldr.w	r6, [ip, #68]	; 0x44

        temp = SYSCFG->EXTICR[position >> 2];
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 8000c34:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 8000c38:	f509 399c 	add.w	r9, r9, #79872	; 0x13800
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 8000c3c:	4b3d      	ldr	r3, [pc, #244]	; (8000d34 <HAL_GPIO_Init+0x1d4>)
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000c3e:	f446 4680 	orr.w	r6, r6, #16384	; 0x4000

        temp = SYSCFG->EXTICR[position >> 2];
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 8000c42:	4298      	cmp	r0, r3
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000c44:	f8cc 6044 	str.w	r6, [ip, #68]	; 0x44
 8000c48:	f8dc 6044 	ldr.w	r6, [ip, #68]	; 0x44
 8000c4c:	f406 4680 	and.w	r6, r6, #16384	; 0x4000
 8000c50:	9603      	str	r6, [sp, #12]
 8000c52:	9e03      	ldr	r6, [sp, #12]

        temp = SYSCFG->EXTICR[position >> 2];
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 8000c54:	f04f 060f 	mov.w	r6, #15
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();

        temp = SYSCFG->EXTICR[position >> 2];
 8000c58:	f8d9 b008 	ldr.w	fp, [r9, #8]
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 8000c5c:	fa06 f60a 	lsl.w	r6, r6, sl
 8000c60:	ea2b 0606 	bic.w	r6, fp, r6
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 8000c64:	d024      	beq.n	8000cb0 <HAL_GPIO_Init+0x150>
 8000c66:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8000c6a:	4298      	cmp	r0, r3
 8000c6c:	d022      	beq.n	8000cb4 <HAL_GPIO_Init+0x154>
 8000c6e:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8000c72:	4298      	cmp	r0, r3
 8000c74:	d020      	beq.n	8000cb8 <HAL_GPIO_Init+0x158>
 8000c76:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8000c7a:	4298      	cmp	r0, r3
 8000c7c:	d01e      	beq.n	8000cbc <HAL_GPIO_Init+0x15c>
 8000c7e:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8000c82:	4298      	cmp	r0, r3
 8000c84:	d01c      	beq.n	8000cc0 <HAL_GPIO_Init+0x160>
 8000c86:	4540      	cmp	r0, r8
 8000c88:	d01c      	beq.n	8000cc4 <HAL_GPIO_Init+0x164>
 8000c8a:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8000c8e:	4298      	cmp	r0, r3
 8000c90:	d01a      	beq.n	8000cc8 <HAL_GPIO_Init+0x168>
 8000c92:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8000c96:	4298      	cmp	r0, r3
 8000c98:	d018      	beq.n	8000ccc <HAL_GPIO_Init+0x16c>
 8000c9a:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8000c9e:	4298      	cmp	r0, r3
 8000ca0:	d016      	beq.n	8000cd0 <HAL_GPIO_Init+0x170>
 8000ca2:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8000ca6:	4298      	cmp	r0, r3
 8000ca8:	bf14      	ite	ne
 8000caa:	230a      	movne	r3, #10
 8000cac:	2309      	moveq	r3, #9
 8000cae:	e010      	b.n	8000cd2 <HAL_GPIO_Init+0x172>
 8000cb0:	2300      	movs	r3, #0
 8000cb2:	e00e      	b.n	8000cd2 <HAL_GPIO_Init+0x172>
 8000cb4:	2301      	movs	r3, #1
 8000cb6:	e00c      	b.n	8000cd2 <HAL_GPIO_Init+0x172>
 8000cb8:	2302      	movs	r3, #2
 8000cba:	e00a      	b.n	8000cd2 <HAL_GPIO_Init+0x172>
 8000cbc:	2303      	movs	r3, #3
 8000cbe:	e008      	b.n	8000cd2 <HAL_GPIO_Init+0x172>
 8000cc0:	2304      	movs	r3, #4
 8000cc2:	e006      	b.n	8000cd2 <HAL_GPIO_Init+0x172>
 8000cc4:	2305      	movs	r3, #5
 8000cc6:	e004      	b.n	8000cd2 <HAL_GPIO_Init+0x172>
 8000cc8:	2306      	movs	r3, #6
 8000cca:	e002      	b.n	8000cd2 <HAL_GPIO_Init+0x172>
 8000ccc:	2307      	movs	r3, #7
 8000cce:	e000      	b.n	8000cd2 <HAL_GPIO_Init+0x172>
 8000cd0:	2308      	movs	r3, #8
 8000cd2:	fa03 f30a 	lsl.w	r3, r3, sl
        SYSCFG->EXTICR[position >> 2] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8000cd6:	f415 3f80 	tst.w	r5, #65536	; 0x10000
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();

        temp = SYSCFG->EXTICR[position >> 2];
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 8000cda:	ea43 0306 	orr.w	r3, r3, r6
        SYSCFG->EXTICR[position >> 2] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
        temp &= ~((uint32_t)iocurrent);
 8000cde:	ea6f 0604 	mvn.w	r6, r4
        __HAL_RCC_SYSCFG_CLK_ENABLE();

        temp = SYSCFG->EXTICR[position >> 2];
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
        SYSCFG->EXTICR[position >> 2] = temp;
 8000ce2:	f8c9 3008 	str.w	r3, [r9, #8]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 8000ce6:	683b      	ldr	r3, [r7, #0]
        temp &= ~((uint32_t)iocurrent);
 8000ce8:	bf0c      	ite	eq
 8000cea:	4033      	andeq	r3, r6
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
        {
          temp |= iocurrent;
 8000cec:	4323      	orrne	r3, r4
        }
        EXTI->IMR = temp;

        temp = EXTI->EMR;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8000cee:	f415 3f00 	tst.w	r5, #131072	; 0x20000
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
        {
          temp |= iocurrent;
        }
        EXTI->IMR = temp;
 8000cf2:	f8ce 3000 	str.w	r3, [lr]

        temp = EXTI->EMR;
 8000cf6:	f8de 3004 	ldr.w	r3, [lr, #4]
        temp &= ~((uint32_t)iocurrent);
 8000cfa:	bf0c      	ite	eq
 8000cfc:	4033      	andeq	r3, r6
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
        {
          temp |= iocurrent;
 8000cfe:	4323      	orrne	r3, r4
        EXTI->EMR = temp;

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8000d00:	f415 1f80 	tst.w	r5, #1048576	; 0x100000
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
        {
          temp |= iocurrent;
        }
        EXTI->EMR = temp;
 8000d04:	607b      	str	r3, [r7, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 8000d06:	68bb      	ldr	r3, [r7, #8]
        temp &= ~((uint32_t)iocurrent);
 8000d08:	bf0c      	ite	eq
 8000d0a:	4033      	andeq	r3, r6
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
        {
          temp |= iocurrent;
 8000d0c:	4323      	orrne	r3, r4
        }
        EXTI->RTSR = temp;

        temp = EXTI->FTSR;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8000d0e:	02ad      	lsls	r5, r5, #10
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
        {
          temp |= iocurrent;
        }
        EXTI->RTSR = temp;
 8000d10:	f8ce 3008 	str.w	r3, [lr, #8]

        temp = EXTI->FTSR;
 8000d14:	f8de 300c 	ldr.w	r3, [lr, #12]
        temp &= ~((uint32_t)iocurrent);
 8000d18:	bf54      	ite	pl
 8000d1a:	4033      	andpl	r3, r6
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
        {
          temp |= iocurrent;
 8000d1c:	4323      	orrmi	r3, r4
        }
        EXTI->FTSR = temp;
 8000d1e:	60fb      	str	r3, [r7, #12]
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0; position < GPIO_NUMBER; position++)
 8000d20:	3201      	adds	r2, #1
 8000d22:	2a10      	cmp	r2, #16
 8000d24:	f47f af28 	bne.w	8000b78 <HAL_GPIO_Init+0x18>
        }
        EXTI->FTSR = temp;
      }
    }
  }
}
 8000d28:	b005      	add	sp, #20
 8000d2a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000d2e:	bf00      	nop
 8000d30:	40013c00 	.word	0x40013c00
 8000d34:	40020000 	.word	0x40020000
 8000d38:	40023800 	.word	0x40023800
 8000d3c:	40021400 	.word	0x40021400

08000d40 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 8000d40:	b902      	cbnz	r2, 8000d44 <HAL_GPIO_WritePin+0x4>
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16;
 8000d42:	0409      	lsls	r1, r1, #16
 8000d44:	6181      	str	r1, [r0, #24]
 8000d46:	4770      	bx	lr

08000d48 <HAL_GPIO_TogglePin>:
void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->ODR ^= GPIO_Pin;
 8000d48:	6943      	ldr	r3, [r0, #20]
 8000d4a:	4059      	eors	r1, r3
 8000d4c:	6141      	str	r1, [r0, #20]
 8000d4e:	4770      	bx	lr

08000d50 <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8000d50:	4a07      	ldr	r2, [pc, #28]	; (8000d70 <HAL_NVIC_SetPriorityGrouping+0x20>)
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 8000d52:	0200      	lsls	r0, r0, #8
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8000d54:	68d3      	ldr	r3, [r2, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 8000d56:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
 8000d5a:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8000d5e:	041b      	lsls	r3, r3, #16
 8000d60:	0c1b      	lsrs	r3, r3, #16
 8000d62:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 8000d66:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8000d6a:	4303      	orrs	r3, r0
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 8000d6c:	60d3      	str	r3, [r2, #12]
 8000d6e:	4770      	bx	lr
 8000d70:	e000ed00 	.word	0xe000ed00

08000d74 <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8000d74:	4b19      	ldr	r3, [pc, #100]	; (8000ddc <HAL_NVIC_SetPriority+0x68>)
 8000d76:	68db      	ldr	r3, [r3, #12]
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 8000d78:	f3c3 2302 	ubfx	r3, r3, #8, #3
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 8000d7c:	b530      	push	{r4, r5, lr}
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8000d7e:	f1c3 0407 	rsb	r4, r3, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000d82:	1d1d      	adds	r5, r3, #4
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8000d84:	2c04      	cmp	r4, #4
 8000d86:	bf28      	it	cs
 8000d88:	2404      	movcs	r4, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000d8a:	2d06      	cmp	r5, #6

  return (
 8000d8c:	f04f 0501 	mov.w	r5, #1
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000d90:	bf8c      	ite	hi
 8000d92:	3b03      	subhi	r3, #3
 8000d94:	2300      	movls	r3, #0

  return (
 8000d96:	fa05 f404 	lsl.w	r4, r5, r4
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
 8000d9a:	2800      	cmp	r0, #0
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
 8000d9c:	f104 34ff 	add.w	r4, r4, #4294967295	; 0xffffffff
 8000da0:	ea04 0401 	and.w	r4, r4, r1
 8000da4:	fa04 f403 	lsl.w	r4, r4, r3
 8000da8:	fa05 f303 	lsl.w	r3, r5, r3
 8000dac:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
 8000db0:	ea02 0203 	and.w	r2, r2, r3
 8000db4:	ea42 0204 	orr.w	r2, r2, r4
 8000db8:	ea4f 1202 	mov.w	r2, r2, lsl #4
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
 8000dbc:	da05      	bge.n	8000dca <HAL_NVIC_SetPriority+0x56>
  {
    SCB->SHPR[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000dbe:	f000 000f 	and.w	r0, r0, #15
 8000dc2:	b2d2      	uxtb	r2, r2
 8000dc4:	4b06      	ldr	r3, [pc, #24]	; (8000de0 <HAL_NVIC_SetPriority+0x6c>)
 8000dc6:	541a      	strb	r2, [r3, r0]
 8000dc8:	bd30      	pop	{r4, r5, pc}
  }
  else
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000dca:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 8000dce:	b2d2      	uxtb	r2, r2
 8000dd0:	f500 4061 	add.w	r0, r0, #57600	; 0xe100
 8000dd4:	f880 2300 	strb.w	r2, [r0, #768]	; 0x300
 8000dd8:	bd30      	pop	{r4, r5, pc}
 8000dda:	bf00      	nop
 8000ddc:	e000ed00 	.word	0xe000ed00
 8000de0:	e000ed14 	.word	0xe000ed14

08000de4 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8000de4:	3801      	subs	r0, #1
 8000de6:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 8000dea:	d20a      	bcs.n	8000e02 <HAL_SYSTICK_Config+0x1e>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8000dec:	4b06      	ldr	r3, [pc, #24]	; (8000e08 <HAL_SYSTICK_Config+0x24>)
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHPR[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000dee:	21f0      	movs	r1, #240	; 0xf0
 8000df0:	4a06      	ldr	r2, [pc, #24]	; (8000e0c <HAL_SYSTICK_Config+0x28>)
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8000df2:	6058      	str	r0, [r3, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8000df4:	2000      	movs	r0, #0
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHPR[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000df6:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000dfa:	2207      	movs	r2, #7
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8000dfc:	6098      	str	r0, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000dfe:	601a      	str	r2, [r3, #0]
 8000e00:	4770      	bx	lr
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
  {
    return (1UL);                                                   /* Reload value impossible */
 8000e02:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 8000e04:	4770      	bx	lr
 8000e06:	bf00      	nop
 8000e08:	e000e010 	.word	0xe000e010
 8000e0c:	e000ed00 	.word	0xe000ed00

08000e10 <HAL_MPU_ConfigRegion>:
  /* Check the parameters */
  assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));
  assert_param(IS_MPU_REGION_ENABLE(MPU_Init->Enable));

  /* Set the Region number */
  MPU->RNR = MPU_Init->Number;
 8000e10:	7843      	ldrb	r3, [r0, #1]
 8000e12:	4911      	ldr	r1, [pc, #68]	; (8000e58 <HAL_MPU_ConfigRegion+0x48>)
 8000e14:	608b      	str	r3, [r1, #8]

  if ((MPU_Init->Enable) != RESET)
 8000e16:	7803      	ldrb	r3, [r0, #0]
 8000e18:	b1db      	cbz	r3, 8000e52 <HAL_MPU_ConfigRegion+0x42>
    assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));
    
    MPU->RBAR = MPU_Init->BaseAddress;
 8000e1a:	6843      	ldr	r3, [r0, #4]
 8000e1c:	60cb      	str	r3, [r1, #12]
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
 8000e1e:	7ac3      	ldrb	r3, [r0, #11]
 8000e20:	7b02      	ldrb	r2, [r0, #12]
 8000e22:	061b      	lsls	r3, r3, #24
 8000e24:	ea43 7302 	orr.w	r3, r3, r2, lsl #28
 8000e28:	7802      	ldrb	r2, [r0, #0]
 8000e2a:	4313      	orrs	r3, r2
 8000e2c:	7a82      	ldrb	r2, [r0, #10]
 8000e2e:	ea43 43c2 	orr.w	r3, r3, r2, lsl #19
 8000e32:	7b42      	ldrb	r2, [r0, #13]
 8000e34:	ea43 4382 	orr.w	r3, r3, r2, lsl #18
 8000e38:	7b82      	ldrb	r2, [r0, #14]
 8000e3a:	ea43 4342 	orr.w	r3, r3, r2, lsl #17
 8000e3e:	7bc2      	ldrb	r2, [r0, #15]
 8000e40:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8000e44:	7a42      	ldrb	r2, [r0, #9]
 8000e46:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8000e4a:	7a02      	ldrb	r2, [r0, #8]
 8000e4c:	ea43 0342 	orr.w	r3, r3, r2, lsl #1
 8000e50:	e000      	b.n	8000e54 <HAL_MPU_ConfigRegion+0x44>
                ((uint32_t)MPU_Init->Enable                  << MPU_RASR_ENABLE_Pos);
  }
  else
  {
    MPU->RBAR = 0x00;
 8000e52:	60cb      	str	r3, [r1, #12]
    MPU->RASR = 0x00;
 8000e54:	610b      	str	r3, [r1, #16]
 8000e56:	4770      	bx	lr
 8000e58:	e000ed90 	.word	0xe000ed90

08000e5c <HAL_PWREx_EnableOverDrive>:
  */
HAL_StatusTypeDef HAL_PWREx_EnableOverDrive(void)
{
  uint32_t tickstart = 0;

  __HAL_RCC_PWR_CLK_ENABLE();
 8000e5c:	2300      	movs	r3, #0
  *         During the Over-drive switch activation, no peripheral clocks should be enabled.   
  *         The peripheral clocks must be enabled once the Over-drive mode is activated.   
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PWREx_EnableOverDrive(void)
{
 8000e5e:	b573      	push	{r0, r1, r4, r5, r6, lr}
  uint32_t tickstart = 0;

  __HAL_RCC_PWR_CLK_ENABLE();
 8000e60:	9301      	str	r3, [sp, #4]
 8000e62:	4b19      	ldr	r3, [pc, #100]	; (8000ec8 <HAL_PWREx_EnableOverDrive+0x6c>)
  
  /* Enable the Over-drive to extend the clock frequency to 216 MHz */
  __HAL_PWR_OVERDRIVE_ENABLE();
 8000e64:	4c19      	ldr	r4, [pc, #100]	; (8000ecc <HAL_PWREx_EnableOverDrive+0x70>)
  */
HAL_StatusTypeDef HAL_PWREx_EnableOverDrive(void)
{
  uint32_t tickstart = 0;

  __HAL_RCC_PWR_CLK_ENABLE();
 8000e66:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  __HAL_PWR_OVERDRIVE_ENABLE();

  /* Get tick */
  tickstart = HAL_GetTick();

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
 8000e68:	4625      	mov	r5, r4
  */
HAL_StatusTypeDef HAL_PWREx_EnableOverDrive(void)
{
  uint32_t tickstart = 0;

  __HAL_RCC_PWR_CLK_ENABLE();
 8000e6a:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8000e6e:	641a      	str	r2, [r3, #64]	; 0x40
 8000e70:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8000e72:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8000e76:	9301      	str	r3, [sp, #4]
 8000e78:	9b01      	ldr	r3, [sp, #4]
  
  /* Enable the Over-drive to extend the clock frequency to 216 MHz */
  __HAL_PWR_OVERDRIVE_ENABLE();
 8000e7a:	6823      	ldr	r3, [r4, #0]
 8000e7c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8000e80:	6023      	str	r3, [r4, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
 8000e82:	f7ff fe59 	bl	8000b38 <HAL_GetTick>
 8000e86:	4606      	mov	r6, r0

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
 8000e88:	686b      	ldr	r3, [r5, #4]
 8000e8a:	4c10      	ldr	r4, [pc, #64]	; (8000ecc <HAL_PWREx_EnableOverDrive+0x70>)
 8000e8c:	03da      	lsls	r2, r3, #15
 8000e8e:	d407      	bmi.n	8000ea0 <HAL_PWREx_EnableOverDrive+0x44>
  {
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
 8000e90:	f7ff fe52 	bl	8000b38 <HAL_GetTick>
 8000e94:	1b80      	subs	r0, r0, r6
 8000e96:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8000e9a:	d9f5      	bls.n	8000e88 <HAL_PWREx_EnableOverDrive+0x2c>
    {
      return HAL_TIMEOUT;
 8000e9c:	2003      	movs	r0, #3
 8000e9e:	e011      	b.n	8000ec4 <HAL_PWREx_EnableOverDrive+0x68>
    }
  }
  
  /* Enable the Over-drive switch */
  __HAL_PWR_OVERDRIVESWITCHING_ENABLE();
 8000ea0:	6823      	ldr	r3, [r4, #0]
 8000ea2:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8000ea6:	6023      	str	r3, [r4, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
 8000ea8:	f7ff fe46 	bl	8000b38 <HAL_GetTick>
 8000eac:	4605      	mov	r5, r0

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
 8000eae:	6863      	ldr	r3, [r4, #4]
 8000eb0:	039b      	lsls	r3, r3, #14
 8000eb2:	d406      	bmi.n	8000ec2 <HAL_PWREx_EnableOverDrive+0x66>
  {
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
 8000eb4:	f7ff fe40 	bl	8000b38 <HAL_GetTick>
 8000eb8:	1b40      	subs	r0, r0, r5
 8000eba:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8000ebe:	d9f6      	bls.n	8000eae <HAL_PWREx_EnableOverDrive+0x52>
 8000ec0:	e7ec      	b.n	8000e9c <HAL_PWREx_EnableOverDrive+0x40>
    {
      return HAL_TIMEOUT;
    }
  } 
  return HAL_OK;
 8000ec2:	2000      	movs	r0, #0
}
 8000ec4:	b002      	add	sp, #8
 8000ec6:	bd70      	pop	{r4, r5, r6, pc}
 8000ec8:	40023800 	.word	0x40023800
 8000ecc:	40007000 	.word	0x40007000

08000ed0 <BSP_LED_Init>:
  *          This parameter can be one of the following values:
  *            @arg  LED1
  * @retval None
  */
void BSP_LED_Init(Led_TypeDef Led)
{
 8000ed0:	b530      	push	{r4, r5, lr}
  GPIO_InitTypeDef  gpio_init_structure;
  GPIO_TypeDef*     gpio_led;

  if (Led == LED1)
 8000ed2:	4604      	mov	r4, r0
  *          This parameter can be one of the following values:
  *            @arg  LED1
  * @retval None
  */
void BSP_LED_Init(Led_TypeDef Led)
{
 8000ed4:	b087      	sub	sp, #28
  GPIO_InitTypeDef  gpio_init_structure;
  GPIO_TypeDef*     gpio_led;

  if (Led == LED1)
 8000ed6:	b9d0      	cbnz	r0, 8000f0e <BSP_LED_Init+0x3e>
  {
    gpio_led = LED1_GPIO_PORT;
    /* Enable the GPIO_LED clock */
    LED1_GPIO_CLK_ENABLE();
 8000ed8:	4b0e      	ldr	r3, [pc, #56]	; (8000f14 <BSP_LED_Init+0x44>)

    /* Configure the GPIO_LED pin */
    gpio_init_structure.Pin = GPIO_PIN[Led];
 8000eda:	2502      	movs	r5, #2

  if (Led == LED1)
  {
    gpio_led = LED1_GPIO_PORT;
    /* Enable the GPIO_LED clock */
    LED1_GPIO_CLK_ENABLE();
 8000edc:	9000      	str	r0, [sp, #0]
    gpio_init_structure.Pin = GPIO_PIN[Led];
    gpio_init_structure.Mode = GPIO_MODE_OUTPUT_PP;
    gpio_init_structure.Pull = GPIO_PULLUP;
    gpio_init_structure.Speed = GPIO_SPEED_HIGH;
  
    HAL_GPIO_Init(gpio_led, &gpio_init_structure);
 8000ede:	a901      	add	r1, sp, #4

  if (Led == LED1)
  {
    gpio_led = LED1_GPIO_PORT;
    /* Enable the GPIO_LED clock */
    LED1_GPIO_CLK_ENABLE();
 8000ee0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    gpio_init_structure.Pin = GPIO_PIN[Led];
    gpio_init_structure.Mode = GPIO_MODE_OUTPUT_PP;
    gpio_init_structure.Pull = GPIO_PULLUP;
    gpio_init_structure.Speed = GPIO_SPEED_HIGH;
  
    HAL_GPIO_Init(gpio_led, &gpio_init_structure);
 8000ee2:	480d      	ldr	r0, [pc, #52]	; (8000f18 <BSP_LED_Init+0x48>)

  if (Led == LED1)
  {
    gpio_led = LED1_GPIO_PORT;
    /* Enable the GPIO_LED clock */
    LED1_GPIO_CLK_ENABLE();
 8000ee4:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8000ee8:	631a      	str	r2, [r3, #48]	; 0x30
 8000eea:	6b1b      	ldr	r3, [r3, #48]	; 0x30

    /* Configure the GPIO_LED pin */
    gpio_init_structure.Pin = GPIO_PIN[Led];
 8000eec:	9501      	str	r5, [sp, #4]

  if (Led == LED1)
  {
    gpio_led = LED1_GPIO_PORT;
    /* Enable the GPIO_LED clock */
    LED1_GPIO_CLK_ENABLE();
 8000eee:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8000ef2:	9300      	str	r3, [sp, #0]
 8000ef4:	9b00      	ldr	r3, [sp, #0]

    /* Configure the GPIO_LED pin */
    gpio_init_structure.Pin = GPIO_PIN[Led];
    gpio_init_structure.Mode = GPIO_MODE_OUTPUT_PP;
 8000ef6:	2301      	movs	r3, #1
 8000ef8:	9302      	str	r3, [sp, #8]
    gpio_init_structure.Pull = GPIO_PULLUP;
 8000efa:	9303      	str	r3, [sp, #12]
    gpio_init_structure.Speed = GPIO_SPEED_HIGH;
 8000efc:	2303      	movs	r3, #3
 8000efe:	9304      	str	r3, [sp, #16]
  
    HAL_GPIO_Init(gpio_led, &gpio_init_structure);
 8000f00:	f7ff fe2e 	bl	8000b60 <HAL_GPIO_Init>
    
    /* By default, turn off LED */
    HAL_GPIO_WritePin(gpio_led, GPIO_PIN[Led], GPIO_PIN_RESET);
 8000f04:	4622      	mov	r2, r4
 8000f06:	4629      	mov	r1, r5
 8000f08:	4803      	ldr	r0, [pc, #12]	; (8000f18 <BSP_LED_Init+0x48>)
 8000f0a:	f7ff ff19 	bl	8000d40 <HAL_GPIO_WritePin>
  }
}
 8000f0e:	b007      	add	sp, #28
 8000f10:	bd30      	pop	{r4, r5, pc}
 8000f12:	bf00      	nop
 8000f14:	40023800 	.word	0x40023800
 8000f18:	40022000 	.word	0x40022000

08000f1c <BSP_LED_On>:
  */
void BSP_LED_On(Led_TypeDef Led)
{
  GPIO_TypeDef*     gpio_led;

  if (Led == LED1)	/* Switch On LED connected to GPIO */
 8000f1c:	b920      	cbnz	r0, 8000f28 <BSP_LED_On+0xc>
  {
    gpio_led = LED1_GPIO_PORT;
    HAL_GPIO_WritePin(gpio_led, GPIO_PIN[Led], GPIO_PIN_SET);
 8000f1e:	2201      	movs	r2, #1
 8000f20:	2102      	movs	r1, #2
 8000f22:	4802      	ldr	r0, [pc, #8]	; (8000f2c <BSP_LED_On+0x10>)
 8000f24:	f7ff bf0c 	b.w	8000d40 <HAL_GPIO_WritePin>
 8000f28:	4770      	bx	lr
 8000f2a:	bf00      	nop
 8000f2c:	40022000 	.word	0x40022000

08000f30 <BSP_LED_Off>:
  */
void BSP_LED_Off(Led_TypeDef Led)
{
  GPIO_TypeDef*     gpio_led;

  if (Led == LED1) /* Switch Off LED connected to GPIO */
 8000f30:	4602      	mov	r2, r0
 8000f32:	b918      	cbnz	r0, 8000f3c <BSP_LED_Off+0xc>
  {
    gpio_led = LED1_GPIO_PORT;
    HAL_GPIO_WritePin(gpio_led, GPIO_PIN[Led], GPIO_PIN_RESET);
 8000f34:	2102      	movs	r1, #2
 8000f36:	4802      	ldr	r0, [pc, #8]	; (8000f40 <BSP_LED_Off+0x10>)
 8000f38:	f7ff bf02 	b.w	8000d40 <HAL_GPIO_WritePin>
 8000f3c:	4770      	bx	lr
 8000f3e:	bf00      	nop
 8000f40:	40022000 	.word	0x40022000

08000f44 <BSP_LED_Toggle>:
  */
void BSP_LED_Toggle(Led_TypeDef Led)
{
  GPIO_TypeDef*     gpio_led;

  if (Led == LED1)	/* Toggle LED connected to GPIO */
 8000f44:	b918      	cbnz	r0, 8000f4e <BSP_LED_Toggle+0xa>
  {
    gpio_led = LED1_GPIO_PORT;
    HAL_GPIO_TogglePin(gpio_led, GPIO_PIN[Led]);
 8000f46:	2102      	movs	r1, #2
 8000f48:	4801      	ldr	r0, [pc, #4]	; (8000f50 <BSP_LED_Toggle+0xc>)
 8000f4a:	f7ff befd 	b.w	8000d48 <HAL_GPIO_TogglePin>
 8000f4e:	4770      	bx	lr
 8000f50:	40022000 	.word	0x40022000

08000f54 <__libc_init_array>:
 8000f54:	b570      	push	{r4, r5, r6, lr}
 8000f56:	4e0f      	ldr	r6, [pc, #60]	; (8000f94 <__libc_init_array+0x40>)
 8000f58:	4d0f      	ldr	r5, [pc, #60]	; (8000f98 <__libc_init_array+0x44>)
 8000f5a:	1b76      	subs	r6, r6, r5
 8000f5c:	10b6      	asrs	r6, r6, #2
 8000f5e:	bf18      	it	ne
 8000f60:	2400      	movne	r4, #0
 8000f62:	d005      	beq.n	8000f70 <__libc_init_array+0x1c>
 8000f64:	3401      	adds	r4, #1
 8000f66:	f855 3b04 	ldr.w	r3, [r5], #4
 8000f6a:	4798      	blx	r3
 8000f6c:	42a6      	cmp	r6, r4
 8000f6e:	d1f9      	bne.n	8000f64 <__libc_init_array+0x10>
 8000f70:	4e0a      	ldr	r6, [pc, #40]	; (8000f9c <__libc_init_array+0x48>)
 8000f72:	4d0b      	ldr	r5, [pc, #44]	; (8000fa0 <__libc_init_array+0x4c>)
 8000f74:	1b76      	subs	r6, r6, r5
 8000f76:	f000 f88b 	bl	8001090 <_init>
 8000f7a:	10b6      	asrs	r6, r6, #2
 8000f7c:	bf18      	it	ne
 8000f7e:	2400      	movne	r4, #0
 8000f80:	d006      	beq.n	8000f90 <__libc_init_array+0x3c>
 8000f82:	3401      	adds	r4, #1
 8000f84:	f855 3b04 	ldr.w	r3, [r5], #4
 8000f88:	4798      	blx	r3
 8000f8a:	42a6      	cmp	r6, r4
 8000f8c:	d1f9      	bne.n	8000f82 <__libc_init_array+0x2e>
 8000f8e:	bd70      	pop	{r4, r5, r6, pc}
 8000f90:	bd70      	pop	{r4, r5, r6, pc}
 8000f92:	bf00      	nop
 8000f94:	080010c0 	.word	0x080010c0
 8000f98:	080010c0 	.word	0x080010c0
 8000f9c:	080010c8 	.word	0x080010c8
 8000fa0:	080010c0 	.word	0x080010c0

08000fa4 <register_fini>:
 8000fa4:	4b02      	ldr	r3, [pc, #8]	; (8000fb0 <register_fini+0xc>)
 8000fa6:	b113      	cbz	r3, 8000fae <register_fini+0xa>
 8000fa8:	4802      	ldr	r0, [pc, #8]	; (8000fb4 <register_fini+0x10>)
 8000faa:	f000 b805 	b.w	8000fb8 <atexit>
 8000fae:	4770      	bx	lr
 8000fb0:	00000000 	.word	0x00000000
 8000fb4:	08000fc5 	.word	0x08000fc5

08000fb8 <atexit>:
 8000fb8:	2300      	movs	r3, #0
 8000fba:	4601      	mov	r1, r0
 8000fbc:	461a      	mov	r2, r3
 8000fbe:	4618      	mov	r0, r3
 8000fc0:	f000 b814 	b.w	8000fec <__register_exitproc>

08000fc4 <__libc_fini_array>:
 8000fc4:	b538      	push	{r3, r4, r5, lr}
 8000fc6:	4d07      	ldr	r5, [pc, #28]	; (8000fe4 <__libc_fini_array+0x20>)
 8000fc8:	4c07      	ldr	r4, [pc, #28]	; (8000fe8 <__libc_fini_array+0x24>)
 8000fca:	1b2c      	subs	r4, r5, r4
 8000fcc:	10a4      	asrs	r4, r4, #2
 8000fce:	d005      	beq.n	8000fdc <__libc_fini_array+0x18>
 8000fd0:	3c01      	subs	r4, #1
 8000fd2:	f855 3d04 	ldr.w	r3, [r5, #-4]!
 8000fd6:	4798      	blx	r3
 8000fd8:	2c00      	cmp	r4, #0
 8000fda:	d1f9      	bne.n	8000fd0 <__libc_fini_array+0xc>
 8000fdc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8000fe0:	f000 b85c 	b.w	800109c <_fini>
 8000fe4:	080010cc 	.word	0x080010cc
 8000fe8:	080010c8 	.word	0x080010c8

08000fec <__register_exitproc>:
 8000fec:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8000ff0:	4c25      	ldr	r4, [pc, #148]	; (8001088 <__register_exitproc+0x9c>)
 8000ff2:	6825      	ldr	r5, [r4, #0]
 8000ff4:	f8d5 4148 	ldr.w	r4, [r5, #328]	; 0x148
 8000ff8:	4606      	mov	r6, r0
 8000ffa:	4688      	mov	r8, r1
 8000ffc:	4692      	mov	sl, r2
 8000ffe:	4699      	mov	r9, r3
 8001000:	b3c4      	cbz	r4, 8001074 <__register_exitproc+0x88>
 8001002:	6860      	ldr	r0, [r4, #4]
 8001004:	281f      	cmp	r0, #31
 8001006:	dc17      	bgt.n	8001038 <__register_exitproc+0x4c>
 8001008:	1c43      	adds	r3, r0, #1
 800100a:	b176      	cbz	r6, 800102a <__register_exitproc+0x3e>
 800100c:	eb04 0580 	add.w	r5, r4, r0, lsl #2
 8001010:	2201      	movs	r2, #1
 8001012:	f8c5 a088 	str.w	sl, [r5, #136]	; 0x88
 8001016:	f8d4 1188 	ldr.w	r1, [r4, #392]	; 0x188
 800101a:	4082      	lsls	r2, r0
 800101c:	4311      	orrs	r1, r2
 800101e:	2e02      	cmp	r6, #2
 8001020:	f8c4 1188 	str.w	r1, [r4, #392]	; 0x188
 8001024:	f8c5 9108 	str.w	r9, [r5, #264]	; 0x108
 8001028:	d01e      	beq.n	8001068 <__register_exitproc+0x7c>
 800102a:	3002      	adds	r0, #2
 800102c:	6063      	str	r3, [r4, #4]
 800102e:	f844 8020 	str.w	r8, [r4, r0, lsl #2]
 8001032:	2000      	movs	r0, #0
 8001034:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8001038:	4b14      	ldr	r3, [pc, #80]	; (800108c <__register_exitproc+0xa0>)
 800103a:	b303      	cbz	r3, 800107e <__register_exitproc+0x92>
 800103c:	f44f 70c8 	mov.w	r0, #400	; 0x190
 8001040:	f3af 8000 	nop.w
 8001044:	4604      	mov	r4, r0
 8001046:	b1d0      	cbz	r0, 800107e <__register_exitproc+0x92>
 8001048:	f8d5 3148 	ldr.w	r3, [r5, #328]	; 0x148
 800104c:	2700      	movs	r7, #0
 800104e:	e880 0088 	stmia.w	r0, {r3, r7}
 8001052:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
 8001056:	4638      	mov	r0, r7
 8001058:	2301      	movs	r3, #1
 800105a:	f8c4 7188 	str.w	r7, [r4, #392]	; 0x188
 800105e:	f8c4 718c 	str.w	r7, [r4, #396]	; 0x18c
 8001062:	2e00      	cmp	r6, #0
 8001064:	d0e1      	beq.n	800102a <__register_exitproc+0x3e>
 8001066:	e7d1      	b.n	800100c <__register_exitproc+0x20>
 8001068:	f8d4 118c 	ldr.w	r1, [r4, #396]	; 0x18c
 800106c:	430a      	orrs	r2, r1
 800106e:	f8c4 218c 	str.w	r2, [r4, #396]	; 0x18c
 8001072:	e7da      	b.n	800102a <__register_exitproc+0x3e>
 8001074:	f505 74a6 	add.w	r4, r5, #332	; 0x14c
 8001078:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
 800107c:	e7c1      	b.n	8001002 <__register_exitproc+0x16>
 800107e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8001082:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8001086:	bf00      	nop
 8001088:	080010bc 	.word	0x080010bc
 800108c:	00000000 	.word	0x00000000

08001090 <_init>:
 8001090:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001092:	bf00      	nop
 8001094:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8001096:	bc08      	pop	{r3}
 8001098:	469e      	mov	lr, r3
 800109a:	4770      	bx	lr

0800109c <_fini>:
 800109c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800109e:	bf00      	nop
 80010a0:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80010a2:	bc08      	pop	{r3}
 80010a4:	469e      	mov	lr, r3
 80010a6:	4770      	bx	lr
